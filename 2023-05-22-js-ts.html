<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />

    <title>JS/TS Training</title>

    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui"
    />
    <link rel="stylesheet" href="slides/revealjs/reveal.js/dist/reset.css" />
    <link rel="stylesheet" href="slides/revealjs/reveal.js/dist/reveal.css" />
    <link rel="stylesheet" href="slides/revealjs/reveal.js/dist/theme/solarized.css" />

    <!-- Theme used for syntax hislides/ghlighted code -->
    <link rel="stylesheet" href="slides/revealjs/highlight-js-github-theme.css" />
    <link rel="stylesheet" href="slides/revealjs/styles.css" />
  </head>

  <body>
    <div class="reveal">
      <!-- Any section element inside of this container is displayed as a slide -->
      <div class="slides">
        <section data-state="title">
          <h2 class="title" style="font-size: 7rem">
            <b>JavaScript &amp; TypeScript Workshop</b>
          </h2>

          <h4>
            <span class="transparent-bg">
              <a href="https://nilshartmann.net" target="_blank">Nils Hartmann</a>
              |
              <a href="https://twitter.com/nilshartmann" target="_blank">@nilshartmann</a>
            </span>
          </h4>

          <div>
            <h3 style="margin-top: 4rem"><span class="transparent-bg">Repository</span></h3>
            <p>
              <span class="transparent-bg">https://github.com/nilshartmann/js-ts-training</span>
            </p>
            <h3 style="margin-top: 4rem"><span class="transparent-bg">Slides</span></h3>
            <p>
              <span class="transparent-bg">Lokal: 2023-05-22-js-ts.html</span>
            </p>
            <p>
              <span class="transparent-bg"
                >Remote:
                <a href="https://nilshartmann.github.io/js-ts-training/2023-05-22-js-ts.html"
                  >https://nilshartmann.github.io/js-ts-training/2023-05-22-js-ts.html</a
                ></span
              >
            </p>
          </div>
        </section>
        <section>
          <h2>Nils Hartmann</h2>
          <p style="margin-top: 2rem">
            <a href="https://nilshartmann.net" target="_blank">https://nilshartmann.net</a>
            /
            <a href="https://twitter.com/nilshartmann" target="_blank">@nilshartmann</a>
          </p>
          <p style="margin-top: 2rem">
            <em>Freiberuflicher Software-Entwickler, Berater und Trainer aus Hamburg</em>
          </p>
          <p></p>
          <p style="margin-top: 5rem">Java | JavaScript, TypeScript | React | GraphQL</p>
          <div style="display: flex; justify-content: center; margin-top: 2rem">
            <div style="margin-left: 15px">
              <a href="https://graphql.schule/video-kurs"
                ><img
                  style="max-height: 450px"
                  src="slides/images/screenshot-graphql-kurs.png"
                /><br />https://graphql.schule/video-kurs</a
              >
              <br />
            </div>
            <!--  -->
            <div style="margin-left: 100px">
              <a href="https://reactbuch.de"
                ><img
                  style="max-height: 450px"
                  src="slides/images/react-buch-v2.jpg"
                /><br />https://reactbuch.de</a
              >
              <br />
            </div>
          </div>
        </section>

        <section>
          <h2>Und ihr?</h2>
          <ul>
            <li>Stellt euch doch bitte kurz vor...</li>
            <li>
              Eure Vorkenntnisse in <b>JavaScript</b>, <b>TypeScript</b>, <b>Node</b> bzw.
              Web-Frameworks und/oder Programmiersprachen?
            </li>
            <li>Wünsche für diese Schulung? Besondere Themen oder Interessen?</li>
          </ul>
        </section>

        <!-- ============================================================================= -->
        <section>
          <h2>Grundsätzliches</h2>
          <p><b>Jederzeit:</b> Fragen und Diskussionen!</p>
          <p class="fragment">Bitte schaltet Euer Video ein 🙏</p>
          <p class="fragment">Motto: Es gibt keine dummen Fragen!</p>
          <p class="fragment">
            Beteiligt Euch! Macht euch bemerkbar per Audio, Chat oder Zoom Reaktion "Hand erheben"
            <span class="fragment"
              ><img width="50%" src="slides/images/zoom-reaktionen.png"
            /></span>
          </p>

          <p class="fragment">
            Wir machen zwischendurch kleine Übungen, in denen ihr selbst programmieren könnt
          </p>
        </section>

        <section data-markdown>
          <textarea data-template>
### Zeitplan
* Mo. 22. / Di. 23. Mai
* Jeweils 8:30 Uhr bis 16:00 Uhr, jeweils derselbe Zoom-Link
* Mittagspause: 12:00 bis 13 Uhr 🍕 🍝
  * Kürzere Pausen zwischendurch ☕️ 😴
---
### Agenda
* [JavaScript Sprachgrundlagen](#/t-javascript)  
  * Typen
  * [Funktionen](#/t-funktionen)
  * Objekte und Arrays
  * [Klassen und Closures](#/t-klassen)
  * [Module](#/t-module)
* [Asynchrone Programmierung mit Promises](#/t-promises)  
* [TypeScript](#/t-typescript)
  * Grundlagen
  * Union und Intersection Types
  * Generics
  * Decorators
* In den ersten Teilen beschäftigen wir uns "nur" mit JavaScript, ohne TypeScript
  * Syntax, Konzepte und Verhalten bleiben mit TypeScript identisch
  

          </textarea>
        </section>

        <section id="t-javascript">
          <h1>JavaScript</h1>
        </section>
        <section>
          <h3>Bevor wir loslegen...</h3>
          <p class="fragment">
            Wer fühlt sich so, wenn wir über JavaScript "Programmierung" sprechen? 🙋‍♀️🙋‍♂️
          </p>

          <a href="https://twitter.com/lukaseder/status/787216648642109441">
            <img
              class="fragment"
              style="height: 1000px"
              src="slides/images/screenshot-tweet-the-javascript.png"
            />
          </a>
        </section>
        <section>
          <h3>JavaScript: Die Sprache</h3>
          <p>
            ⚠️&nbsp;<em
              >JavaScript wurde in nur
              <a
                href="https://thenewstack.io/brendan-eich-on-creating-javascript-in-10-days-and-what-hed-do-differently-today/"
                >zehn Tagen</a
              ></em
            >&nbsp;erschaffen! 👷
          </p>
        </section>

        <section>
          <h3>JavaScript: Dokumentation</h3>
          <p>
            <em> Documenting web technologies, including CSS, HTML, and JavaScript, since 2005.</em>
          </p>
          <p>👉 <a href="https://developer.mozilla.org">https://developer.mozilla.org</a></p>
        </section>

        <section data-markdown>
          <textarea data-template>
### JavaScript: Dynamisches Typsystem

* In JavaScript haben Variablen _Typen_ (wie in Java)
  *  `boolean`, `number`, `bigint`, `string`, `object`, `null`, `undefined` und `symbol`
* JavaScript hat ein **dynamisches** Typ-System (im Gegensatz zu Java/C#/C++ etc.)
  * Der Typ einer Variable kann sich deswegen jederzeit ändern (ohne Type-Cast o.ä.)
  * ```typescript
    // let creates a variable
    let x = "Hallo"; // Typ von x ist string

    // dynamic typing (vs static typing in C#, java, ...)
    x = 7; // Typ von x === "number"
    x = false; // Typ von x === "boolean"

    x = function() { return "Hallo" } // ...

    x.toUpperCase(); // Ouch 😱
    ```
---
### JavaScript: Dynamisches Typsystem

* Das Typsystem ist außerdem **schwach**, d.h. es werden bei Bedarf automatisch Typ-Konvertierungen durchgeführt:
* ```typescript
  const a = 100;
  const b = true
  const c = a + b; // 101 🥳
  ```
* ```typescript
  const d = true + true + false; // 2 🥳 🥳
  ```
* ```typescript
  const e = false + null + []; // 0 😵‍💫
  ```
* Das dürfte einer der Gründe sein, warum JavaScript bei vielen sehr beliebt 😍, von anderen geradezu gehasst 😡 wird.
* Dazu später mehr  
---
### TypeScript: statisches Typsystem

* TypeScript ist "JavaScript plus statisches Typsystem"
* Das bedeutet: 
  * vollständige JavaScript-Syntax ist auch in TypeScript gültig
  * jeder gültige JavaScript-Code ist gültiger TypeScript Code
* TypeScript fügt "nur" ein statisches Typsystem 
  * dazu erweitertes die Syntax von JavaScript um die Möglichkeit, Typen anzugeben
* Das Laufzeit-Verhalten von JavaScript und TypeScript ist identisch
  * denn: der TypeScript-Code (Typ-Annotationen) wird beim Compilieren komplett entfernt
  * (mit einer kleinen Ausnahme, den enums)
* Historisch hat(te) TypeScript noch mehr Features, die spielen aber praktisch keine Rolle mehr
  * Klassen z.B. gibt's jetzt auch in JavaScript
  
          </textarea>
        </section>
        <!-- ============================================================================= -->
        <section>
          <h3>Control flow</h3>
          <p>Ähnlich wie C#/Java</p>
          <p>if / else</p>
          <p>switch / case / default</p>
          <p>while / do</p>
          <p>break / continue</p>
          <p>try / catch</p>
          <p>Semikolon optional</p>
          <p>
            <a
              href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Control_flow_and_error_handling"
              >Referenz</a
            >
          </p>
        </section>
        <!-- ============================================================================= -->
        <section>
          <h3>Variablen: let und const</h3>

          <pre class="fragment"><code class="javascript">
            // Variable
            let alter = 42;
            alter = 43; // OK
          </code></pre>
          <pre class="fragment"><code class="javascript">

            // Konstante
            const name = "Susi";
            name = "Klaus"; // TypeError: invalid assignment to const 'name'
          </code></pre>

          <p class="fragment">Das veraltete <code>var</code> bitte <b>nicht mehr verwenden</b>!</p>
        </section>

        <!-- ============================================================================= -->
        <section>
          <h3>Operatoren</h3>
          <pre><code class="javascript">
// === (triple equal operator) OHNE implizite Typ-Konvertierung
if (42 === 42) {
  console.log("of course"); // of course
}
if ("3" === 3) {
  console.log("makes sense"); //
}

if ("" === false) {
  console.log("hmm..."); //
}
            </code></pre>
          <pre class="fragment"><code class="javascript">
// == (double equal operator) mit impliziter Typ-Konvertierung
// ("coercion")
if (42 == 42) {
  console.log("of course"); // of course
}
if ("3" == 3) {
  console.log("makes sense"); // makes sense
}
if ("" == false) {
  console.log("hmm..."); // hmm...
}
          </code></pre>

          <p class="fragment"><b>Empfehlung</b>: immer triple-equal-operator verwenden!</p>
        </section>
        <section data-markdown>
          <textarea data-template>
### Coercion

* Type Coercion ist das _implizite_ Konvertieren eines Typs in einen anderen
* Es gibt diverse (unübersichtliche) Regeln dafür in die JavaScript
* Die Regeln sind abhängig von Operator und Typ des Operanden
* Hier gibt es eine gute [Übersicht](https://medium.com/front-end-weekly/implicit-coercion-in-javascript-5077ad5510d)
* Wenn zum Beispiel ein `string` und eine `number` "addiert" werden, wird die `number` in den String konvertiert:
* ```typescript
  let a = 1 + "1";  // 11
  ```
* Bei allen anderen mathematichen Operatoren wird hingegen der String in eine Number konvertiert:
* ```typescript
  let b = 1 - "1"; // 0
  ```
* Viele im Internet gehandelte Probleme sind exotischer Natur, die man normalerweise ohnehin nicht machen würde
  * ```typescript
    let c = [] + 1; // 1
    let d = {} + true // "[object Object]true"
    ```
* Launinger Vortrag zu dem Thema: [WTF JS](https://github.com/denysdovhan/wtfjs)    
* Im richtigen Leben bewahrt uns TypeScript in vielen Fällen vor der falschen Verwendung der Typen

  </textarea
          >
        </section>

        <!-- ============================================================================= -->
        <section>
          <h3>JavaScript: Datentypen</h3>

          <p>boolean, null, undefined, number, string, symbol, bigint</p>

          <p>Diese Typen gibt es auch genauso in TypeScript</p>

          <pre><code class="javascript">
            // typeof liefert den Typ einer Variable als String zurück
            console.log(typeof 123); // "number"
          </code></pre>

          <pre class="fragment"><code class="javascript">
              const check = true; // typeof check === "boolean"
              if (check) {
                console.log("jupp!");
              }
            </code></pre>

          <pre class="fragment"><code class="javascript">
              const age = 32; // typeof age === "number"
              if (age < 16) {
                console.log("No Beer, sorry!")
              }
            </code></pre>

          <pre class="fragment"><code class="javascript">
              const name = "Klaus"; // typeof name === "string"
              if (name === "Klaus") { 
                console.log("Hello, Klaus!");
              }
            </code></pre>

          <pre class="fragment"><code class="javascript">
              let value;
              typeof value === "undefined"

              value = null;
              typeof value !== "undefined"
              typeof value === "???"

            </code></pre>
        </section>
        <!-- ============================================================================= -->
        <section>
          <h3>Template Strings</h3>
          <pre class="fragment"><code class="javascript">

const name = "Susi";

// Template String (with ``)
const greet = `Hello, ${name}`; // Hello, Susi

const loudGreet = `Hello, ${name.toUpperCase()}` // Hello, SUSI

// Zeilenumbrüche bleiben erhalten:      
const letter = `Hello, ${name},

thanks for subscribing to our e-mail newsletter.

Yours, Edgar`;       
          </code></pre>
        </section>
        <section data-markdown>
          <textarea data-template>
### Fehlerbehandlung

* In *synchronem* Code (oder mit async/await): `try`/`catch`/`finally`
* Fast wie aus Java gewohnt
* ```typescript
  try {
    sayHello("Moin", "Klaus")
  } catch (err) {
    console.error("Error", err)
  } finally {
    // ...
  }
  ```
* Mit `throw` könnt ihr jeden beliebigen Wert "werfen"
  * Das ist anders als in Java, wo wie nur `Throwable`s werfen können
  * In der Regel werden Instanzen von `Error` geworfen
  * ```typescript
    throw new Error("Invalid argument!");
    ```
* Es gibt keinen Unterschied zwischen "Checked Exceptions" und "Unchecked Exceptions"    
  * `throws` gibt es in JavaScript nicht
---
### Fehler auffgangen
* Mit `catch` könnt ihr Fehler fangen (wie in Java)    
* Ihr könnt _nicht_ einschränken, welche Fehler(-Typen) ihr fangen wollt (anders als in Java)
* Ihr müsst also im Zweifel überprüfen, was ihr für einen Fehler habt
* (In TypeScript ist der Typ von `err` deswegen `unknown`)
  * ```typescript
    try {
      // ...
    }
    catch (err) {

      if (err instanceof Error) {
        // ...
      } else if (typeof err === "string") {
        // ...
      }

    }
    ```
---
### Eigene Fehler werfen
* Ihr könnt jeden beliebigen Wert werfen
* ```typescript
  throw "Invalid filename"
  throw { message: "Invalid filename", code: 123 };
  ```
* Der Konstruktor von `Error` nimmt einen optionalen Parameter mit einer Messag entgegen
* ```typescript
  throw new Error();
  throw new Error("Invalid filename");
  ```
* `name` und `message` von `Error` könnt ihr dann abfragen:
* ```typescript
  catch (err) {
    console.error(err.name); // "Error"
    console.error(err.message); // "Invalid filename"
  }
  ```
* Es gibt eine Reihe von [eingebauten Error-Typen](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Errors?retiredLocale=de)
* Ihr könnt aber auch einige Spezialisierugen bauen, dazu von `Error` ableiten:
* ```typescript
  class InvalidFilenameError {
    constructor(filename) {
      super(`Invalid filename: ${filename}`);
      this.name = "InvalidFilenameError";
    }
  }
  ```
---
### Error causes

* Wenn ihr einen Error "weiterwerfen" wollt, könnt ihr das `cause`-Property setzen
* Dazu müsst ihr den zweiten Parameter im `Error`-Konstruktor verwenden
* ```typescript
  try {
    // ...
  } catch (err) {
    throw new Error("Could not read file", { cause: err} );
  }
  ```
* Auch `cause` kann jeder beliebige Typ sein
 * Ihr müsst kein `Error`-Objekt übergeben
 * Ihr könnt die `cause` für Detail-Informationen bei jedem Error verwenden
 * ```typescript
   if (fileSize > 123) {
    throw new Error("File too large", { 
      cause: { code: 1, fileSize: fileSize }
    })
   }
   ```

  </textarea
          >
        </section>

        <!-- ============================================================================= -->
        <section data-markdown>
          <textarea data-template>
<!-- .slide: class="left" -->
<!-- .slide: id="t-funktionen" -->
            
### Funktionen
* ```typescript
  function greet(msg) {
    return "Hello, " + msg;
  }

  greet("World"); // Hello, World
  greet(null), // Hello, null
  greet(); // Hello, undefined
  ```
* Eine Funktion in JavaScript kann mit beliebigen Paramtern aufgerufen werden
  * unabhängig davon, wieviele und welche Parameter sie deklariert hat
* In **TypeScript** _müssen_ Funktionsparamter mit einer Typ-Annotation versehen werden
  * Dann ist nur ein "korrekter" Aufruf der Funktion möglich
* ```typescript
  function greet(msg: string) { ... }

  greet("hello"); // OK
  greet(null); // ERR
  greet(); // ERR
  ```  
---
<!-- .slide: class="left" -->            
### Funktionen  
* Funktionen sind "1st-class-citizens" in JavaScript und benötigen keine Klasse o.ä.,
sondern können überall hingeschrieben werden  
  * Genau wie bei anderen Werten können sie auch an Variablen zugeordnet oder als Parameter übergeben werden
* ```typescript
  function greet(msg) { ... }

  const greetSomeone = greet;
  typeof greetSomeone; // "function"

  greetSomeone("World"); // Hello, World
  ```
* ```typescript
  // Referenzen auf Funktionen können als Parameter übergeben werden
  function printer(getMessageFn) {
    console.log(getMessageFn())
  }

  // "inline" Funktion
  printer(function() { return "Hello, World"} );

  function helloWorld() { return  "Hello, World" };
  printer(helloWorld);
  ```
* Übergebene Funktionen werden oft auch als **Callback-Funktionen** bezeichnet
  * In **Java** würde man dafür ein (funktionales) Interface verwenden  


</textarea
          >
        </section>
        <section>
          <h3>Pfeilfunktionen (Arrow Functions)</h3>
          <p>In vielen Fällen "nur" andere Schreibweise als <code>function</code></p>
          <pre><code class="javascript">
  const greet = (msg) => {
    return "Hello, " + msg;
  }
</code></pre>
          <pre class="fragment"><code class="javascript">
  // Bei genau einem Parameter kann die Klammer weggelassen werden:
  const greet = msg => { return "Hello, " + msg }
</code></pre>
          <pre class="fragment"><code class="javascript">
  // Bei keinem oder mehr als einem Parameter muss die Klammer gesetzt werden:
  const greet = (phrase, msg) => { return phrase + msg }
  const greetWorld = () => { return "Hello, World" };

</code></pre>
          <pre class="fragment"><code class="javascript">
  // bei genau einem Ausdruck, können geschweifte Klammern weggelassen werden:
  //   Ergebnis des Ausdrucks dann der Rückabgewert der Funktion:
  const greet = msg => "Hello, " + msg;
</code></pre>
          <pre class="fragment"><code class="javascript">
  // Verhalten wie "normale Funktion"
  greet("World"); // Hello, World
  greet(null), // Hello, null
  greet(); // Hello, undefined

  </code></pre>
        </section>
        <!-- ============================================================================= -->
        <section>
          <h3>Funktionen: Default-Parameter</h3>

          <pre class="fragment"><code class="javascript">
            function add(value, inc = 1) { ... } 
          </code></pre>

          <p class="fragment">
            Der Default-Parameter greift immer, wenn für den Parameter
            <code>undefined</code> übergeben wurde:
          </p>

          <pre class="fragment"><code class="javascript">
            add(1); // entspricht: add(1,1)
          </code></pre>
          <pre class="fragment"><code class="javascript">
            add(1,undefined); // entspricht: add(1,1)
          </code></pre>
          <pre class="fragment"><code class="javascript">
            add(1,2); // entspricht: add(1,2);
          </code></pre>
          <pre class="fragment"><code class="javascript">
            add(1, null); // entspricht; add(1, null);
          </code></pre>
          <pre class="fragment"><code class="javascript">
            add(); // entspricht: add(undefined, 1);
          </code></pre>

          <p class="fragment">
            Mehrere Default-Parameter: danach dürfen keine nicht-Default-Parameter kommen!
          </p>

          <pre class="fragment"><code class="javascript">
            function add(value, inc = 1) { ... } // ok
            function add(value = 0, inc = 1) { ... }  // ok

            function add(value = 0, inc) { ... } // FEHLER
          </code></pre>
        </section>
        <section>
          <h3>Rest-Parameter</h3>

          <p class="fragment">
            <a
              href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/rest_parameters"
              >Rest-Parameter</a
            >
            nehmen alle verbleibenen, übergebenen Parameter auf
          </p>

          <pre class="fragment"><code class="javascript">
            function greet(phrase, ...names) { 
              // ...
            }

            greet("Hello", "World", "Peter", "Susi");

            // phrase ist "Hello",
            // names ist ein Array mit "World", "Peter", "Susi"
          </code></pre>

          <pre class="fragment"><code class="javascript">
            function say(...words) { 
              // ...
            } 

            say("One", "Two");

            // words ist ein Array mit allen Parametern ("One", "Two")
          </code></pre>
        </section>

        <!-- ============================================================================= -->
        <section>
          <h3>Funktionen</h3>
          <p>
            Achtung, return-Anweisung: Ergebnis direkt hinter das <code>return</code>-Keyword
            schreiben:
          </p>

          <pre class="fragment"><code class="javascript">
              function hello() {
                return "Hello";
              }
              const h = hello(); // "Hello"
            </code></pre>
          <pre class="fragment"><code class="javascript">

              function goodbye() {
                return 
                  "Goodbye";    // oh no 😢!
              }

              const g = goodbye(); // undefined
            </code></pre>

          <pre class="fragment"><code class="javascript">
            // oder:
              function hello() {
                return (
                  "Hello"
                );
              }
            </code></pre>
        </section>

        <!-- ============================================================================= -->
        <section>
          <h2>Übung: Strings und Funktionen</h2>
          <p>
            <em>Mache dich mit den JavaScript-Grundlagen vertraut</em>
          </p>

          <p class="fragment">
            Die Beschreibung der Übung findest Du in
            <b><code>js-intro/01_basic/index.js</code></b
            >. Darin kannst Du auch deinen Code schreiben.
          </p>
          <p class="fragment">
            Du kannst die Datei mit <code>node index.js</code> von der Konsole ausführen.
          </p>
          <p class="fragment">Ausgaben erfolgen auf der Konsole.</p>
          <p class="fragment">Bei Fragen oder Problemen, kannst Du dich jederzeit melden</p>
          <p class="fragment">
            Wenn alle Stricke reißen, findest Du eine mögliche Lösung in:
            <code>js-intro/01_basic/solution/index.js</code>
          </p>
          <p class="fragment">Wenn Du fertig bist, bitte "Hand heben" in Zoom 🙋‍♀️</p>
        </section>
        <!-- ============================================================================= -->

        <!-- ============================================================================= -->
        <section data-markdown>
          <textarea data-template>
### Array
* In JavaScript können Arrays alle möglichen Werte und Typen gemischt enthalten
* ```typescript
  const empty = [];
  const dinge = [ "a", 123, { name: "Klaus"}, false];
  ```
* In TypeScript können wir festlegen, welche Typen in einem Array enthalten sein dürfen:
* ```typescript
  const names: Array<string> = ["Klaus", "Susi"];
  
  // oder:
  const names: string[] = ["Klaus", "Susi"];
  ```
* Ein bestehendes Array um neue Einträge erweitern
* ```typescript
  const abc = ["a", "b", "c"];

  abc.push("d", "e"); // ["a", "b", "c", "d", "e"]; // 5

  abc[4]; // e
  abc.length // 5
  ```
* Ein bestehende Array Kopieren und die Kopie erweitern
* ```typescript
  const three = [1, 2, 3];
  const five = three.concat(4, 5)
  // three !== five 
  ```

          </textarea>
        </section>

        <section>
          <h3>JavaScript: Arrays</h3>
          <pre><code class="javascript">
            const fruits = ["apple", "orange"];
          </code></pre>
          <pre class="fragment"><code class="javascript">
            // Iterieren
            for (const f of fruits) {
              console.log(f);
            }
            // "apple"
            // "orange"
  
            fruits.forEach(f => console.log(f));
            // "apple"
            // "orange"
          </code></pre>
          <pre class="fragment"><code class="javascript">
          // Transformieren ("map") eines Arrays

          const bigFruits = fruits.map(v => v.toUpperCase());
          // ["APPLE", "ORANGE"]
          </code></pre>
        </section>

        <!-- ============================================================================= -->
        <section>
          <h3>Objekt</h3>
          <p>Objekte werden als Literal in Form von Key-Value-Paaren geschrieben</p>
          <p>Wir brauchen für Objekte in JavaScript keine Klassen o.ä. (so wie in Java)</p>
          <pre><code class="javascript">
const firstname = "Klaus";

const person = {
  firstname: firstname,
  hobby: "Singing",
  age: 32
}

console.log(typeof person); // "object"
          </code></pre>
          <pre class="fragment"><code class="javascript">
// Auf Properties zugreifen
person.firstname // Klaus

// Zugriff via Index Notation
person["firstname"]; // Klaus
          </code></pre>
          <pre class="fragment"><code class="javascript">
// Werte zuweisen
person.firstname = "Susi"
          </code></pre>
          <pre class="fragment"><code class="javascript">
// Neues Property hinzufügen
person.livesIn = "Hamburg"

// Property entfernen
delete person.livesIn;

// Zugriff auf nicht vorhandenes Property
person.livesIn // undefined
                      </code></pre>
        </section>

        <!-- ============================================================================= -->
        <section>
          <h3>Objekte #2</h3>
          <p class="fragment">Object "Shorthand Notation"</p>
          <pre class="fragment"><code class="javascript">
            const firstname = "Klaus";
        
            const person = {
              firstname,
              hobby: "Singing",
              age: 32
            }
        </code></pre>

          <p class="fragment">Erinnerung: Nur Referenzen sind konstant!</p>

          <pre class="fragment"><code class="javascript">
            // Nur Referenzen sind konstant
            const person = {
              name: "Susi"
            }

            person = "Klaus"; // TypeError: invalid assignment to const 'person'
            person.name = "Klaus" // OK
          </code></pre>
        </section>

        <!-- ============================================================================= -->
        <section>
          <h2>Übung: Arrays, Objekte und Funktionen</h2>

          <p class="fragment">
            Die Beschreibung der Übung findest Du in
            <b><code>js-intro/02_objects_and_arrays/index.js</code></b
            >. Darin kannst Du auch deinen Code schreiben.
          </p>
          <p class="fragment">
            Du kannst die Datei mit <code>node index.js</code> von der Konsole ausführen.
          </p>
          <p class="fragment">Ausgaben erfolgen auf der Konsole.</p>

          <p class="fragment">Bei Fragen oder Problemen, kannst Du dich jederzeit melden</p>
          <p class="fragment">
            Wenn alle Stricke reißen, findest Du eine mögliche Lösung in:
            <code>js-intro/02_objects_and_arrays/solution/index.js</code>
          </p>
          <p class="fragment">Wenn Du fertig bist, bitte "Hand heben" in Zoom 🙋‍♀️</p>
        </section>

        <!-- ============================================================================= -->
        <section>
          <h3>Objekte und Funktionen</h3>

          <p>Objekte können Funktionen enthalten</p>

          <pre><code class="javascript">
const person = {
  firstname: "Susi",
  sayHello() { return "Hello, " + this.firstname},
}

person.sayHello() // Hello, Susi
</code></pre>

          <p class="fragment">Warnung vor "this"!</p>
          <pre class="fragment"><code class="javascript">
const klaus = { 
  firstname: "Klaus", 
  sayHello: person.sayHello
};

klaus.sayHello() // 🤔
</code></pre>

          <pre class="fragment"><code class="javascript">
klaus.sayHello() // Hello, Klaus 😊
</code></pre>

          <pre class="fragment"><code class="javascript">
const sayHelloToSusi = person.sayHello;
sayHelloToSusi(); // 🤔
</code></pre>
          <pre class="fragment"><code class="javascript">
const sayHelloToSusi = person.sayHello;
sayHelloToSusi(); // Hello, undefined 🤪
</code></pre>
        </section>
        <section data-markdown>
          <textarea data-template>
### this-Binding in JavaScript

* In Java zeigt `this` immer auf die Instanz der Klasse, in der `this` verwendet wird
* Das ist in JavaScript nicht so!
* In JavaScript bestimmt der Aufrufer, auf was `this` zeigt. 
  * Man kann sich daher `this` wie einen impliziten, "unsichtbaren" Funktionsparameter vorstellen
* Das `this` bezieht sich in JavaScript auf das Objekt, an dem die Funktion aufgerufen wurde, nicht an dem sie definiert wurde!
* ```typescript
  const susi = {
    firstName: "Susi",
    getName() { return this.firstName }
  }
  susi.getName(); // Susi


  const klaus = { firstName: "Klaus" }
  klaus.getName = susi.getName;

  // 'this' zeigt hier auf das "klaus"-Objekt, nicht auf "susi"!
  klaus.getName(); // Klaus

  const getName = klaus.getName;
  // 'this' zeigt hier auf das globale Objekt (window im Browser)
  getName(); // undefined (globales Objekt hat kein 'firstname')
  ```


---
### Explizites this-Binding
* Ein konkretes `this` kann an eine Funktion explizit gebunden werden.
* Dann ist das `this` _immer_ das gebundene und kann von außen nicht mehr verändert werden
* Dazu wird mit `bind` eine neue Funktion erzeugt. In dieser ist das `this` dann gebunden
* ```typescript
  const p = { firstname: "Klaus", sayHello() { return this.firstname } }
  p.sayHello = p.sayHello.bind(p);

  p.sayHello(); // Klaus

  const s = { firstname: "Susi", sayHello: p.sayHello };
  s.sayHello(); // Klaus 👍 
  ```
* Mit `bind` kann jedes beliebige Objekt (oder `null` oder `undefined`) gebunden werden  
* ```typescript
  const person = { firstname: "Klaus" }
  const employee = { sayHello() { return this.firstname } }

  employee.sayHello(); // undefined (Kein 'firstname' in 'employee')

  employee.sayHello = employee.sayHello.bind(person);

  // this in sayHello zeigt nun auf person:
  employee.sayHello(); // "Klaus"
  ```
* Beim Aufrufen einer Funktion kann das `this` explizit für den Aufruf festgelegt werden
  * Dazu muss `call` bzw. `apply` verwendet werden. Der erste Parameter ist das `this`
  * ```typescript
    const person = { firstname: "Klaus", sayHello() { return this.firstname }};

    person.sayHello(); // Klaus
    person.sayHello.call({firstname: "Susi"}); // Susi
    ```
---
### `this` in TypeScript
* In einer Funktion weiß TypeScript nicht, was `this` ist
  * Geht es uns nicht so ähnlich? 😉
* Aus diesem Grund kann man den [this-Parameter](https://www.typescriptlang.org/docs/handbook/2/classes.html#this-parameters) verwenden
* Wenn der erste Parameter in einer Funktion `this` heißt, kann man darüber den Type von `this` festlegen
* Dieser Parameter wird beim Compilieren entfernt:
* ```typescript
  type Person = { firstname: string };

  const person = { firstname: "Klaus" };

  const employee = {
    sayHello(this: Person) {
      return this.firstname;
    }
  };

  employee.sayHello(); // The 'this' context of type '...' 
                      // is not assignable to method's 'this' of type 'Person'.

  const sayHello = employee.sayHello.bind(person);

  console.log(sayHello());  // OK

  ```

* Im compilierten JavaScript-Code sieht `employee` so aus:
* ```typescript
  const employee = {
    // kein 'this'-Parameter
    sayHello() {
      return this.firstname;
    }
  };
  ```

---
### Objekte und Pfeilfunktionen
* Pfeilfunktionen haben eine andere `this`-Strategie!
* Sie beziehen das `this` aus der Umgebung, in der sie *geschrieben* wurden
* Und das ist auch nicht änderbar!
  * weder mit `bind` noch mit `call` oder `apply`
* Daher eignen sich **nicht** oder nur bedingt für Methoden (also für Funktionen an Objekten):
* ```typescript
  const person = {
    firstname: "Susi",
    sayHello: () => { return "Hello, " + this.firstname }
  }

  person.sayHello();  Hello, undefined 🤪  
  ```
* In dem Fall ist `this` das globale this, das kein `firstname` Property hat

</textarea
          >
        </section>

        <!-- ============================================================================= -->
        <!-- ============================================================================= -->
        <section data-markdown>
          <textarea data-template>
### Mehr zu Objekten und Arrays            
          </textarea>
        </section>
        <section>
          <h3>Destructuring</h3>
          <p>
            Mit dem
            <a
              href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment"
              >object destructuring</a
            >
            Operator kannst Du Werte in einem Objekt an lokale Variablen zuweisen:
          </p>

          <pre><code class="javascript">
            // Ein Objekt...
              const person = {
                firstname: "Susi",
                lastname: "Meier",
                age: 32
              };
            </code></pre>
          <pre class="fragment"><code class="javascript">
              // Zugriff auf Properties (herkömmlich)

              const firstname = person.firstname; // Susi
              const age = person.age; // 32
              const hobby = person.hobby; // undefined
            </code></pre>
          <pre class="fragment"><code class="javascript">
              // Zugriff auf Properties (Destrukturierung)

              const { firstname, age, hobby } = person;

              console.log(firstname); // Susi
              console.log(age); // 32
              console.log(hobby); // undefined
            </code></pre>
        </section>
        <section>
          <h3>Destructuring #2</h3>

          <p class="fragment"><em>Default Werte</em>:</p>

          <pre class="fragment"><code class="javascript">
              const person = {
                firstname: "Susi",
                age: 32
              };

              const { city = "Bonn" } = person;
              console.log(city); // Bonn
            </code></pre>
        </section>
        <section>
          <h3>Destructuring #3</h3>
          <p>Funktionsparameter, die ein Objekt sind, können destrukturiert werden:</p>

          <pre><code class="javascript">
              // Herkömmlich
              function printPerson(person) {
                console.log(`${person.firstname} is ${person.age} years old`);
              }

              printPerson({ firstname: "Susi", age: 32 });
            </code></pre>

          <p class="fragment">Alternative mit Destrukturierung:</p>

          <pre class="fragment"><code class="javascript">
              function printPerson({firstname, age}) {
                console.log(`${firstname} is ${age} years old`);
              }

              printPerson({ firstname: "Susi", age: 32 });
            </code></pre>
        </section>
        <section>
          <h3>Destructuring #3</h3>
          <p>Mit Default-Wert</p>
          <pre><code class="javascript">
             function printPerson({name, age, city="Bonn"}) {
                 console.log(`${name}, ${age} years, lives in ${city}`);
             }
            </code></pre>
          <p class="fragment">🤔 Was wird hier ausgegeben? 🤔</p>
          <pre class="fragment"><code class="javascript">
             
              printPerson({name: "susi", age: 32});
            </code></pre>
          <pre class="fragment"><code class="javascript">
  
              printPerson({name: "susi", age: 32, city: "Freiburg"});
            </code></pre>
          <pre class="fragment"><code class="javascript">
  
              printPerson({name: "susi", age: 32, city: null});
            </code></pre>
          <pre class="fragment"><code class="javascript">
  
              printPerson({name: "susi", age: 32, city: undefined});
            </code></pre>
          <pre class="fragment"><code class="javascript">
  
              printPerson();
             </code></pre>
        </section>

        <section>
          <h3>Object Spread Operator</h3>

          <p>
            Mit dem
            <a
              href="https://developer.mozilla.org/de/docs/Web/JavaScript/Reference/Operators/Spread_syntax"
              >Spread Operator</a
            >
            können alle Felder eines Objektes an eine andere Stelle kopiert werden
          </p>

          <pre class="fragment"><code class="javascript">
            const person = { firstname: "Susi", age: 32 }
          </code></pre>
          <pre class="fragment"><code class="javascript">
            // Kopie erzeugen (herkömmlich)
            const copy = { firstname: person.firstname, age: person.age } 

            // copy: { firstname: "Susi", age: 32}
          </code></pre>
          <pre class="fragment"><code class="javascript">
            // Kopie erzeugen (Spread operator)
            const copy = { ...person };

            // copy: { firstname: "Susi", age: 32}

            copy.age = 33;

            person.age; // 32
          </code></pre>

          <pre class="fragment"><code class="javascript">
            const person = { firstname: "Susi", age: 32 }

            const employee = { ...person, salary: 695000 }
            // employee: { firstname: "Susi", age: 32, salary: 695000 }
          </code></pre>
        </section>

        <!-- ============================================================================= -->
        <section>
          <h3>Destructuring und Spread mit Arrays</h3>
          <p>Beide Operatoren funktionieren auch mit Arrays:</p>

          <pre class="fragment"><code class="javascript">
            // Spread-Operator

            const cities = ["Hamburg", "Bonn"];
            const moreCities = [...cities, "Köln"];
          </code></pre>

          <pre class="fragment"><code class="javascript">
            // Destructuring
            const cities = ["Hamburg", "Bonn", "Köln"];
            const [hamburg, bonn] = cities;

            console.log(hamburg); // Hamburg
            console.log(bonn); // Bonn
          </code></pre>
        </section>

        <!-- ============================================================================= -->
        <!-- ============================================================================= -->
        <section>
          <h3>Truthy und falsy</h3>
          <p>
            <b><a href="https://developer.mozilla.org/de/docs/Glossary/Falsy">falsy</a></b> ist ein
            Wert, der <b>false</b> wird, wenn er (implizit oder explizit) in ein Boolean konvertiert
            wird
          </p>
          <p>
            <b><a href="https://developer.mozilla.org/de/docs/Glossary/Truthy">truthy</a></b> ist
            ein Wert, der <b>true</b> wird, wenn er (implizit oder explizit) in ein Boolean
            konvertiert wird (das sind alle Werte, die nicht falsy sind)
          </p>

          <pre><code class="javascript">
    if (true) { console.log("I'm true") } // I'm true

    if ("hello") { console.log("I'm true") } // I'm true
    
    if (null) { console.log("I'm falsy") } // 

    if (undefined) { console.log("I'm falsy") } // 
  </code></pre>

          <p class="fragment">Was ist mit diesen?</p>

          <pre class="fragment"><code class="javascript">
    if (0) { console.log("will this be shown?"); } // 🤔
  </code></pre>

          <pre class="fragment"><code class="javascript">
    if ("") { console.log("will this be shown?"); } // 🤔
  </code></pre>

          <pre class="fragment"><code class="javascript">
    if ([]) { console.log("will this be shown?"); } // 🤔
  </code></pre>

          <pre class="fragment"><code class="javascript">
    if ({}) { console.log("will this be shown?"); } // 🤔
  </code></pre>
        </section>

        <!-- ============================================================================= -->
        <section>
          <h3>Truthy und falsy #2</h3>

          <p>Insbesondere mit <code>0</code> und Leerstring aufpassen:</p>

          <pre class="fragment"><code class="javascript">
        function add(a, b) {
          if (!a || !b) {
            throw new Error("Invalid Argument!");
          }

          return a + b;
        }
      </code></pre>
          <pre class="fragment"><code class="javascript">
        add(2, 1);  // 3 👍
        add(1, null); // "Invalid Argument" 👍
      </code></pre>

          <pre class="fragment"><code class="javascript">
        add(1, 0); // "Invalid Argument" 🤦
      </code></pre>
        </section>

        <section data-markdown>
          <textarea data-template>
### Truthy und falsy #3

* Mit Default-Werten (Destructuring) und Default-Parametern (Funktionen) aufpassen
* Defaults werden nur verwendet, wenn der entsprechende Wert `undefined` ist
* `truthy` bzw. `falsy` spielen hier keine Rolle!
* ```javascript
  const person = { firstname: null };

  const { firstname = "Susi" } = person; // firstname: null!
  ```
* ```javascript
  function sayHello(name = "Susi") { return "Hello, " + name }

  sayHello(null); // Hello, null
  ```
---
### Operatoren mit truthy/falsy

* Der logische Und-Operator (`&&`) liefert die _rechte_ Seite eines Ausdrucks, wenn der Ausdruck auf der linken Seite `truthy` ist:
* ```typescript
  const a = "eins" && "zwei"; // a === "zwei"
  ```
* Ansonsten wird der Ausdruck auf der linken Seite zurückgeliefert
  * Dieser muss nicht false sein!
  * ```typescript
    const firstName = "";
    const a = firstName.length > 3 && "Name korrekt"; // false
    const b = firstName && "Name ist leer"; // 🤔
    ```
  * ```typescript
    const b = firstName && "Name ist leer"; // ""
    ```
* Bei dem logischen Oder-Operator `||` ist es umgekehrt, _rechte_ Seite wird zurückgeliefert, wenn linke Seite `falsy` ist
* ```typescript
  const a = "".length || "Name ist leer"; // "Name ist leer"
  const b = "Klaus".length || "Name ist leer"; // 5
```
* Der [Nullish coalescing operator](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Nullish_coalescing) liefert
den _rechten_ Ausdruck nur zurück, wenn der linke Ausdruck `null` oder `undefined` ist:
* ```typescript
  const name = null;
  const msg = name ?? "Name ist null"; // Name ist null

  const firstname = "";
  const err = firstname ?? "Name ist leer"; // ""
  ```

    




  </textarea
          >
        </section>
        <!-- ============================================================================= -->
        <section>
          <h2>Übung: Arbeiten mit Objekten</h2>

          <p class="fragment">
            Die Beschreibung der Übung findest Du in
            <b><code>js-intro/03_objects/index.js</code></b
            >. Darin kannst Du auch deinen Code schreiben.
          </p>
          <p class="fragment">
            Du kannst die Datei mit <code>node index.js</code> von der Konsole ausführen.
          </p>
          <p class="fragment">Ausgaben erfolgen auf der Konsole.</p>
          <p class="fragment">Bei Fragen oder Problemen, kannst Du dich jederzeit melden</p>
          <p class="fragment">
            Wenn alle Stricke reißen, findest Du eine mögliche Lösung in:
            <code>js-intro/03_objects/solution/index.js</code>
          </p>
          <p class="fragment">Wenn Du fertig bist, bitte "Hand heben" in Zoom 🙋‍♀️</p>
        </section>

        <section data-markdown>
          <textarea data-template>
<!-- .slide: id="t-klassen" -->
### Klassen

* Klassen können in JavaScript mit `class` erzeugt werden
* Sie sind von der Syntax und von den Möglichkeiten etwas anders als in Java.
* In JavaScript spielen sie eher eine untergeordnete Rolle
  * Insbesondere tiefe Vererbungshierarchien sind eher ungewöhnlich
  * Meist werden einfache Objekte, Funktionen und/oder Closures verwendet
  * Zum Arbeiten mit stateful Daten (z.B. Caches) aber durchaus nützlich
* ```typescript
  class Person {
    firstname;

    constructor(f) {
      this.firstname = f;
    }

    sayHello() {
      return `Hello, ${this.firstname}`
    }
  }
  ```
---
### Klassen

* Alle Eigenschaften in einer Klasse sind per Default **public**
* Auf die Eigenschaften muss auch innerhalb der Klasse **immer** mit `this` zugegriffen werden
* ```typescript
  class Person {
    firstname = "Susi";

    sayHello() {
      return `Hello, ${firstname}` // ReferenceError: firstname is not defined
    }
  }
  ```

* Es kann max. einen Konstruktor geben
  * Der Konstruktur muss `constructor` heißen



---
### Vererbung
* Mit `extends` kann eine Klasse von einer anderen erben
* Wenn die Oberklasse einen `constructor` hat, muss die Unterklasse auch einen
  Konstruktur haben und als erstes `super()` aufrufen
* Mit `super` haben wir in der Unterklasse Zugriff auf die Eigenschaften der Oberklasse (wie in Java)  
* ```typescript
  class Person {
    firstname;
    constructor(firstname) { this.firstname = firstname; }
    sayHello() { return `Hello, ${this.firstname}` }
  }
  ```
* ```typescript
  class Employee extends Person {
    company;
    constructor(firstname, company) {
      super(firstname);
      this.company = company;
    }
    sayHello() {
      return `${super.sayHello()} working at ${this.company}`
    }

    increaseSallary() { }
  }
  ```
* ```typescript
  const p = new Person("Klaus");
  p.sayHello(); // "Hello, Klaus"  

  const e = new Employee("Susi", "Hier GmbH");
  e.sayHello(); // "Hello, Susi working at Hier GmbH"
  e.increaseSallary(); // OK

  p.increaseSallary(); TypeError: p.increaseSallary is not a function 
  ```
---
### Statische Methoden und Felder
* Statische Methoden und Felder werden mit `static` angegeben
* Zugriff meistens mit `Klassenname.statischeEigenschaft`:
* ```typescript
  class Person {
    static verifyAge(a) { return a > 18 }

    setAge(newAge) {
      // Zugriff aus Klasse:
      Person.verifyAge(a);
    }
  }

  // Zugriff von außerhalb:
  Person.verifyAge(23);

  ```
* Innerhalb einer statischen Methode kann auf andere statische Eigenschaften mit `this` zugegriffen werden:
* ```typescript
  class Person {
    static minAge = 18;
    static verifyAge(a) { return a > this.minAge }
    // ...
  }
  ```
* Statische Eigenschaften können in Unterklassen überschrieben werden:
* ```typescript
  class Person {
    static minAge = 18;
    static verifyAge(a) { return a > this.minAge }
    // ...
  }

  class Senior extends Person {
    static minAge = 32;
  }

  Person.verifyAge(19) // TRUE
  Senior.verifyAge(19) // FALSE
  Senior.verifyAge(33) // TRUE

  ```

  
---
### Private Eigenschaften
* Statische Methoden, Methoden und Felder können mit einem führenden `#` versehen werden
* Diese Eigenschaften sind dann "private" und können nur in der Klasse selbst verwendet werden
  * Auch nicht in Unterklassen
  * Verhalten ähnlich wie in Java

* ```typescript
  class Person {
    // Privates Feld
    #firstname;

    // Private statische Methode
    static #verifyName(n) {
      if (!n) {
        throw new Error("Illegal name")
      }
    }

    get firstname() {
      return this.#firstname || "Kein Firstname";
    }

    set firstname(f) {
      Person.#verifyName(f);
      this.#firstname = f;
    }
  }

  const p = new Person();
  p.firstname; // "Kein Firstname";
  p.firstname = ""; // Illegal name
  p.firstname = "Klaus"
  p.firstname; // Klaus

  ```
---
### Klassen in TypeScript
* Die Notation ist in TypeScript (fast) identisch
* Es müssen Typ-Annotation für Felder sowie Constructor- und Methoden-Parameter gemacht werden
* ```typescript
  class Person {
    firstname: string // firstname ist public
    private age: number;

    constructor(n: string, a: number) { this.firstname = n; this.age = age }
  }

  const p = new Person("Klaus", 32);
  p.firstname; // Klaus
  p.age; // TS ERR: Property 'age' is private

  ```
* Methoden und Felder können `public` (default) oder `protected` bzw. `private` sein
* Kurzschreibweise für Felder:
* ```typescript
  class Person {
    constructor(public firstname: string, private age: number) {}

    sayHello() { return `Hello, ${this.firstname}, you are ${this.age} years old` }
  }

  const p = new Person("Klaus", 32);
  p.sayHello(); // Hello, Klaus, you are 32 years old
  ```
---
### Klassen in TypeScript  
* Klassen können TypeScript Interfaces implementieren
* ```typescript
  interface Greetable { 
    sayHello(s: string): string
  }
  class Greeter implements Greetable { sayHello(s) { return "Hello " + s} }
  class MoinGreeter implements Greetable { sayHello(s) { return "Moin " + s} }

  function greet(g: Greetable) {
    console.log(g.sayHello("Susi"));
  }

  greet(new Greeter()) // Hello Susi
  greet(new MoinGreeter()) // Moin Susi
  ```
* Achtung! Interfaces sind eine TypeScript Sprachererweitung. 
  * Sie nach dem Compilieren weg, und können z.B. nicht mit `instanceof` überprüft werden
---
### Closures
<!-- .slide: class="left" -->
* Eine "normale" Funktion...
* ```typescript
  function count() {
    let v = 1;

    v = v + 1;

    return v;
  }
  ```
* ```typescript
  count(); // 2
  ```
  * Nach der Ausführung der Funktion wird diese abgeräumt und mit ihr alle Daten
  * Bei erneuter Ausführung der Funktion wird diese neu initialisiert und beginnt von vorne:
* ```typescript
  count(); // 2
  count(); // 2
  count(); // 2
  ```
---
### Closures

* Eine Closure ist eine Funktion, die nicht nur "sich selbst", sondern auch ihre Umgebung (äußere Funktion(en)) kennt
* Dadurch kann diese Funktion eine "Instanz" haben
* Im Gegensatz zu einer "normalen" Funktion, behält die Closure ihre "inneren" Daten (Variablen, Funktionen) 
* Diese Daten werden _Closures_ genannt und nicht von der Laufzeitumgebung abgeräumt
* ```typescript
  function counter() {
    let v = 1;

    function count() {
      v = v + 1;
      return v;
    }

    return count;
  }
  ```
* ```typescript
  const c = counter(); // counter liefert 'count'-Funktion zurück!
  c(); // 2
  c(); // 3
  c(); // 4

  const d = counter(); // zweite "Instanz" von count!
  d(); // 2
  d(); // 3

  ```
* Die Daten/Closures von `counter` würden hier erst abgeräumt, wenn `c` bzw. `d` nicht mehr verwendet werden 
---
### Closures
* Eine Closure hat Zugriff auf alle äußeren "Scopes", bis hin zum globalen Scope
* ```typescript
  let c = 1;
  function counter() {
    let d = c + 1; // Zugriff auf globalen Scope

    function count() {
      let e = c + d; // Zugriff auf höheren und globalen Scope
      return e;
    }
  }
  ```
* Von außen kann man nicht in die Closure eingreifen
* Dadurch kann man z.B. Sichtbarkeiten implementieren
* ```typescript
  function calculator(initialValue) {
    let value = initialValue ?? 0; // "privat"

    function assertValidNumber(v) { // "privat"
      if (typeof v !== "number") { throw new Error("not a number!") }
    }

    function add(v) {
      assertValidNumber(v);
      value = value + v;
      return value;
    }

    function substract(v) {
      assertValidNumber(v);
      value = value - v;
      return value;
    }

    return { add, substract };
  }
  ```
* ```typescript
  const c = calculator(2);
  c.add(1); // 3
  c.substract(4); // -1
  ```
---
### Lambda
<!-- .slide: class="left" -->
* Begriffe Lambda und Closure werden manchmal synonym verwendet
* Als _Lambda_ wird aber eine anonyme, innere Funktionen bezeichnet
* ```typescript
  function addListener(fn) { ... }

  function app() {
    registerListener( () => console.log("Event!") ); // Lambda
  }
  ```
* In _Java_ ist eine Lambda keine "echte" Closure
* Darum müssen in _Java_ verwendete Variablen "effective final" sein
  * ```java
    // Java !!
    class A {
      void multiply(List<Integer> values) {
          int v = 2;
          values.stream().map(i -> i * v); // OK, lese-Zugriff auf v
      }

      void sum(List<Integer> values) {
          int sum = 0;
          values.stream().forEach(i -> sum += i ); // ERR: Variable used in lambda expression 
                                                  // should be final or effectively final
      }
    }
    ```
  



  


---
### Typ von Funktionen
* Eine `function` ist eine "Unterklasse" eines Objekts in in JavaScript und kein eigener Datentyp
* ```typescript
  function greet(msg) {
    return "Hello, " + msg;
  }

  greet instanceof Object; // true
  ```
* `typeof` liefert für eine Funktion (trotzdem) den eindeutigen String `function` zurück:
* ```typescript
  function greet(msg) {
    return "Hello, " + msg;
  }

  typeof greet; // "function"
  ```
* auch eine Klasse ist übrigens eine Funktion:
* ```typescript
  class Greeter { 
    greet(msg) { 
      console.log("Hello, " + msg);
    }
  }
  
  typeof Greeter; // "function" 🤦
  ```
---
### Übung: Klassen und Closures

* *Implementiere einen einfachen Cache* als **Closure** und als **Klasse**
* In `06_closures_and_classes` findest Du zwei JavaScript-Dateien:
  * In der Datei `make_cache_class.js` baust Du den Cache als JavaScript Klasse:
  * In der Datei `make_cache_closure.js` baust Du den Cache als Closure
* Aufgabe und Beschreibung ist in beiden Dateien unterschiedlich, nur deine Implementierung unterscheidet sich :-)
* Lösung findest Du in `solution`
* Wenn Du fertig bist, bitte Hand in Zoom heben 🙋  
  </textarea
          >
        </section>
        <!-- ============================================================================= -->
        <section id="t-module">
          <h3>Module</h3>
          <p>Module bestimmen explizit, was außerhalb verwendet werden darf</p>
          <p>Module geben explizit an, was sie aus anderen Modulen verwenden wollen</p>
        </section>

        <section data-markdown>
          <textarea data-template>
### Modulsysteme: Common JS vs ECMAScript Module
* Das ECMAScript (oder JavaScript) Modul System (ESM) kam erst 2015 in die Sprache
* Common JS ist das Modulsystem von Node.JS
* Node.JS unterstützt mittlerweile aber auch das JavaScript Modulsystem
  * Auch TypeScript unterstützt beide Modulsysteme
  * Ihr müsst Euch für das Ausgabe-Format entscheiden (CommonJS oder ESM)
* Auch wenn das CommonJS Modulsystem nicht eingestellt wird, geht die Tendenz zu ESM
  * Viele Bibliotheken bieten mittlerweile beide Formate (oder nur noch ESM) an
---
### Unterschiede und Gemeinsamkeiten
* In beiden Modulsystem ist ein **Modul** eine **Datei**
  * In Java und anderen Programmiersprachen ist ein Modul tendenziell eine Sammlung von Dateien/Klassen
* Externe Bibliotheken werden als **Packages** zur Verfügung gestellt (npm: node *package* manager)
  * Die Bibliotheken können ihren Code für ein oder mehrere Modulsysteme zur Verfügung stellen
* CommonJS Module werden synchron geladen, ES Module hingegen asynchron
  * Das macht einen Mischbetrieb für die Laufzeitumgebung komplex
* CommonJS Module funktionieren nicht im Browser 
* CommonJS flexibler, `require` kann überall verwendet werden, `import` nur am Beginn einer Datei
---
### Module im Browser
* Browser unterstützen nur das JavaScript Modulsystem
  * Und das proprietäre AMD 
* Um auch Node.JS Module nutzen zu können, verwenden die meisten JS Frontend Tools sog. "Bundler"
* Ein Bundler analysiert Eure JavaScript-Dateien und kann die verwendeten Modulsysteme "entfernen"  
* Dazu wird der Code durch Code ersetzt, der im Browser ausführbar ist
  * Bekannte Bundler: [Webpack](https://webpack.js.org/) und [Rollup](https://rollupjs.org/)
  * [esbuild](https://esbuild.github.io/) und [TurboPack](https://turbo.build/pack) sind noch recht neu, versprechen aber bessere Performance
---
### Das JavaScript Modulsystem
* Das JavaScript Modulsystem könnt ihr verwenden, wenn ihr:
  * in Eurer `package.json`-Datei den `type`-Eintrag auf `module` setzt
    * ```json
      {
        "type": "module"
      }
      ```
  * oder in Dateien, die die Endung `.mjs` tragen         
  </textarea
          >
        </section>

        <!-- ============================================================================= -->
        <section>
          <h3>Module</h3>
          <h4>Default Exporte</h4>
          <p>
            <em
              >Objekte, Funktionen, Klassen etc müssen explizit <b>exportiert</b> und
              <b>importiert</b> werden</em
            >
          </p>

          <pre class="fragment"><code class="javascript">
            // src/domain/Person.js
            export default function createPerson { ... }

            oder

            function createPerson { ... }
            export default createPerson
          </code></pre>

          <pre class="fragment"><code class="javascript">
              // src/domain/Person.js
              export default function createPerson() { ... }

              oder

              function createPerson() { ... }
              export default createPerson;
            </code></pre>

          <pre class="fragment"><code class="javascript">
                Nur EIN Default Export erlaubt;
                export default function createPerson() { ... }
                export default function makePerson { ... } // KONFLIKT
              </code></pre>
        </section>

        <!-- ============================================================================= -->
        <section>
          <h3>Module</h3>
          <h4>Importieren</h4>
          <p class="fragment">Beim importieren geben wir Pfade(!) an</p>
          <p class="fragment">
            Die Endung <code>.js</code> wird auch verwendet, wenn die importierte Datei eine
            TypeScript-Datei ist!
          </p>
          <p class="fragment">
            Wenn in der <code>package.json</code>-Datei als <code>type</code> <b>nicht</b>
            <code>module</code> eingetragen ist, müssen die Dateien die Endung
            <code>.mjs</code> haben
          </p>

          <pre class="fragment"><code class="javascript">
              // src/domain/Person.js
              export default function createPerson() { ... }

            </code></pre>

          <pre class="fragment"><code class="javascript">
                // src/App.js
                import createPerson from "./domain/Person.js";

                const person = createPerson("Lemmy", "Kilmister");
              </code></pre>
        </section>

        <!-- ============================================================================= -->
        <section>
          <h3>Module</h3>
          <h4>Benannte Exporte</h4>
          <p class="fragment">
            Ein Modul kann neben einem Default auch beliebig viele
            <b>benannte Exporte</b> haben
          </p>

          <pre class="fragment"><code class="javascript">
                // src/domain/Person.js
                export default function createPerson { ...}

                export function updatePerson() { ... }
                export function removePerson() { ... }
              </code></pre>

          <pre class="fragment"><code class="javascript">
                  // src/domain/Person.js
                  function createPerson { ...}
                  function updatePerson() { ... }
                  function removePerson() { ... }

                  export default createPerson;

                  export { updatePerson, removePerson }
                </code></pre>
        </section>

        <!-- ============================================================================= -->
        <section>
          <h3>Module</h3>
          <h4>Benannte Importe</h4>
          <pre class="fragment"><code class="javascript">
                    // src/App.js
                    import { removePerson } from "./Person"
              </code></pre>
          <pre class="fragment"><code class="javascript">
                // Default und benannten Export importieren
                import createPerson, { removePerson } from "./Person.js"
              </code></pre>
        </section>
        <!-- ============================================================================= -->
        <!-- <section>
          <h3>Übung: Module</h3>

          <p>Vorbereitung</p>
          <ol>
            <li class="fragment">
              Öffne das Verzeichnis <code>js-intro/04_modules</code> im Terminal
            </li>
            <li class="fragment">Führe <code>npx http-server</code> in dem Verzeichnis aus</li>
            <li class="fragment">
              Öffne die Seite <a href="http://localhost:8080">http://localhost:8080</a> im Browser
            </li>
            <li class="fragment">Wenn Du die Seite geöffnet hast, bitte "Hand heben" in Zoom 🙋‍♀️</li>
          </ol>
        </section>
 -->
        <section>
          <h2>Übung: Module</h2>

          <p class="fragment">
            Die Beschreibung der Übung findest Du in
            <b><code>js-intro/04_modules/index.js</code></b
            >. Darin kannst Du auch deinen Code schreiben.
          </p>
          <p class="fragment">Du kannst die Anwendung mit <code>node index.js</code> ausführen.</p>
          <p class="fragment">Alle Ausgaben erfolgen im Terminal auf der Konsole.</p>
          <p class="fragment">Bei Fragen oder Problemen, kannst Du dich jederzeit melden</p>
          <p class="fragment">
            Wenn alle Stricke reißen, findest Du eine mögliche Lösung in:
            <code>js-intro/04_modules/solution/</code>
          </p>
          <p class="fragment">Wenn Du fertig bist, bitte "Hand heben" in Zoom 🙋‍♀️</p>
        </section>
        <!-- ============================================================================= -->

        <section data-markdown>
          <textarea data-template>
<!-- .slide: id="t-promises" -->            
### Asynchrone Programmierung mit JavaScript
* JavaScript ist single-threaded
* Jeder Code, den wir ausführen ist erstmal blockierend
* Threads wie in Java gibt es nicht
* Um asynchronen Code auszuführen, gibt es zwei Möglichkeiten
  * Promise API und async/await (JavaScript Sprach Standard)
  * Callback-API von Node.JS
---
### Hintergrund: Node.JS Callback API
* Promises wurden erst 2015 in die JavaScript Sprache aufgenommen
  * async/await sogar noch später, 2017
* Node.JS hat aus diesem Grund das Callback-Pattern bekannt gemacht
* Hier wird einer Funktion, die asynchron arbeiten soll, eine Callback-Funktion übergeben
  * Die Callback-Funktion ist jeweils der letzte Parameter, der übergeben wird
  * ```typescript
    function readFile(filename, callbackFn) { /* ... */ }
    ```
  
  * Diese Funktion wird entweder mit einem Fehler oder dem Ergebnis augefrufen
  * Das Ergebnis war die "Callback-Hölle" 😈
  * ```typescript
    readFile("helloWorld.txt", (err, data) => {
      if (data) {
        parseLines(data, (err, lines) => {
          if (lines) {
            countWords(lines, (err, lines) => {
              // ...
            })
          }
        })
      }
    })
    ```
  

          </textarea>
        </section>
        <section>
          <h3>Promises in JavaScript</h3>

          <p class="fragment">
            Ein Promise liefert einen "Versprechen" auf einen Wert zurück, der evtl. erst in der
            Zukunft ermittelt werden kann
          </p>
          <p class="fragment">
            Damit können wir asynchrones Verhalten in JavaScript Applikation abbilden
          </p>
          <pre class="fragment"><code class="javascript" contenteditable>
// "getNameAsync" ist eine ausgedachte Funktion, 
// die ein Promise zurückliefert, 
// das "irgendwann" den String "Klaus" zurückgibt
const promise = getNameAsync();
  </code></pre>
          <pre
            class="fragment"
          ><code class="javascript" contenteditable>promise.then(name => console.log(name));
// Ausgabe "irgendwann": "Klaus"
  </code></pre>
        </section>

        <section>
          <h3>Promises</h3>
          <p>Promises können verkettet werden</p>
          <pre><code class="javascript" contenteditable>
// Annahme: 'getNameAsync' liefert "irgendwann" den String "Klaus" zurück
const promise = getNameAsync()

// Wird mit dem ersten Wert aufgerufen und gibt neuen Wert zurück
.then(name => getGreetingAsync(name)) 

// wird mit dem zweiten Wert (aus vorherigem then) aufgerufen
.then(greeting => console.log(greeting));

// Ausgabe "irgendwann": 
// "Hello, Klaus"

  </code></pre>
          <p class="fragment">
            Die <code>then</code>-Funktion gibt <b>immer</b> ein Promise zurück
          </p>
        </section>

        <section>
          <h3>Fehlerbehandlung</h3>
          <h4>Mit <code>catch()</code> kann man Fehler fangen und darauf reagieren</h4>
          <pre class="fragment"><code class="javascript" contenteditable>
  const promise = getNameAsync()

    .then(name => { if (name === null) throw new Error("No name found") })

    .then(greeting => console.log(greeting));

    .catch(error => console.error(`Greeting failed: ${error}`))
  
    // Wenn 'getNameAsync' null zurückliefert ist die Ausgabe:
    //   Greeting failed: No name found
    </code></pre>
        </section>

        <!-- ============================================================================= -->
        <section>
          <h3>Finally</h3>

          <p class="fragment">
            Eine <code>finally</code>-Callback-Funktion wird nach dem letzten <code>then</code> bzw.
            <code>catch</code>-Block ausgeführt.
          </p>

          <p class="fragment">
            Die finally-Funktion wird <b>immer</b> ausgeführt (unabhängig davon, ob vorher ein
            Fehler aufgetreten ist oder nicht
          </p>

          <pre class="fragment"><code class="javascript" contenteditable>
              const promise = getNameAsync();

                .then(name => { if (name === null) throw new Error("No name found") })

                .then(greeting => console.log(greeting));

                .catch(error => console.error(`Greeting failed: ${error}`))

                .finally( () => console.log("Goodbye!") );
              
                // Output (error): Greeting failed: No name found
                // Output (log): Goodbye!
                </code></pre>
        </section>

        <section>
          <h3>Promise.all</h3>

          <p class="fragment">
            Mit
            <a
              href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/all"
              >Promise.all</a
            >
            kannst Du auf eine Liste von Promises warten
          </p>

          <p class="fragment">
            Die Funktion wird nur ausgeführt, wenn alle übergebenen Promises aufgelöst werden
            konnten
          </p>

          <pre class="fragment"><code class="javascript" contenteditable>
              const user = loadUserAsync(); // gibt Promise zurück
              const newsFeed = loadNewsFeedAsync(); // gibt Promise zurück

              Promise.all(user, newsFeed)
                .then(result => {
                  const loadedUser = result[0];
                  const newsFeed = result[1];

                  return { user: loadedUser, news: newsFeed };
                });
                </code></pre>

          <p class="fragment">
            Verwandt:
            <a
              href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/any"
              >Promise.any</a
            >
            und
            <a
              href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/allSettled"
              >Promise.allSettled</a
            >
          </p>
        </section>
        <section data-markdown>
          <textarea data-template>
### Promises erzeugen
* In der Regel werdet ihr API-Funktionen aufrufen, die ein Promise zurückliefern
* Ihr könnt aber mit dem Promise-Konstruktor auch eigene Promises erzeugen
* Dem Konstruktor übergebt ihr eine Callback-Funktion, in der ihr Eure Logik implementiert
  * Diese Funktion wird von JavaScript mit zwei Parametern aufgerufen:
    * `resolve`-Funktion. Die ruft ihr mit dem ermittelten Wert auf
      * Mit dem übergebenen Wert wird dann die erste `then`-Funktion aufgerufen
    * `reject`-Funktion: die ruft ihr (mit einem Fehler) auf, wenn ihr den Wert nicht ermitteln konntet
      * Mit dem übergebenen Wert wird dann die erste `catch`-Funktion aufgerufen             
* ```typescript
  const p = new Promise((resolve, reject) => {
    setTimeout(() => {
      return resolve("Zeit ist abgelaufen")
      });
    }, timeout);
  });
  ```
---
### Promises in Node.JS
* Die API von Node.JS verwendet für Asynchronität das Callback-Pattern `(err, data) => { ... }`
* Mit [`util.promisify`](https://nodejs.org/dist/latest-v8.x/docs/api/util.html#util_util_promisify_original)
könnt ihr eine Node.JS-Funktion, die dem Callback-Pattern folgt, in eine Funktion mit Promises "konvertieren"
* Wichtig ist, das die an `promisify` übergebene Funktion die Callback-Funktion als letzten Parameter erwartet
* Callback-Pattern:
  * ```typescript
    function loadData(filename, callback) { /* ... */ }

    loadData("hallo.txt", (err, data) => { /* ... */ })
    ```
* Mit `promisify`:
  * ```typescript
    const util = require('util');
    
    function loadData(filename, callback) { /* ... */ }
    
    const loadDataPromise = util.promisify(loadData);

    loadDataPromise("hallo.txt")
      .then(data => /* ... */ );
    ```
          </textarea>
        </section>

        <section>
          <h2>async / await</h2>
          <p>"Nur" eine andere Art/API, um mit Promises zu arbeiten</p>
          <p>Erlaubt es, asynchronen Code "linear" hinzuschreiben</p>
        </section>
        <section>
          <h3>async / await</h3>
          <p><code>await</code> wartet bis ein Promise aufgelöst wird</p>
          <pre class="fragment"><code class="javascript" contenteditable data-trim>
    function greet(name) { return new Promise(...); }
    
    // await can only be used in 'async'-functions:
    async function sayWhat(name) {
      const greeting = await greet(name);
    
      // greeting is a string!
      console.log(greeting); // => Hello, ...
    }
                      </code></pre>
        </section>
        <section>
          <h3>async / await</h3>
          <p><code>async</code> machen eine Funktion zu einer "async function"</p>
          <p class="fragment">
            Eine <code>async</code> Funktion gibt &nbsp; <b>immer</b> ein Promise zurück
          </p>
          <pre class="fragment"><code class="javascript" contenteditable data-trim>
  async function greet(name) {
    return `Hello, ${name}`;
  }
  
  const greeting = greet('Klaus');
  
  // greeting is a Promise!
  console.log(greeting instanceof Promise); // => true
  console.log(greeting) // => Promise {&lt;resolved>: "Hello, Klaus"}
                  </code></pre>
          <p class="fragment"><code>async</code> Funktion als Fat Arrow Funktionen:</p>
          <pre class="fragment"><code class="javascript" contenteditable data-trim>
  const greet = async (name) => `Hello, ${name}`;                
    
  const greeting = greet('Klaus');
    
  // greeting is a promise!
  console.log(greeting instanceof Promise); // => true
  console.log(greeting) // => Promise {&lt;resolved>: "Hello, Klaus"}
                    </code></pre>
        </section>

        <section data-markdown>
          <textarea data-template>
### Top-Level await in Node.JS
* Seit Node 14.8, könnt ihr `await` auch auf Top-Level-Ebene verwenden
* Ihr braucht dann keine `async`-Funktion mehr
  * (Falls ihr `await` in einer Funktion nutzt, muss diese weiterhin `async` sein)
* Achtung! Das geht nur in JavaScript Modulen (ESM)  
          </textarea>
        </section>

        <section>
          <h3>async / await</h3>
          <p>
            Anstatt <code>then</code> oder <code>catch</code>-Ketten kannst Du einfach mehrere
            <code>await</code> Statements verwenden und try/catch für die Fehlerbehandlung:
          </p>
          <pre class="fragment"><code class="javascript" contenteditable data-trim>
  // Return promises
  async function loadUser(username) { . . . };
  async function loadProfileDate(userId) { . . .};
  
  async function loadData() {
    try {
      const user = await loadUser('klaus');
      const profile = await loadProfileData(user.userId);
    } catch (e) {
      console.error("Something failed")
    }
  }
---
### Übung: Promises API
- _Arbeite mit der Promise API_
- Es gibt zwei Übungsdateien:
  1. `js-intro/10_promises/index.js`
  2. `js-intro/10_promises/promisify.js`
- In diesen beiden Dateien findest Du die Aufgaben
- Du kannst die Dateien jeweils mit `node` ausführen, Ausgaben sollten dann im Terminal auf der Konsole erscheinen
- Bei Fragen oder Problemen, kannst Du dich jederzeit melden
- Lösungen findest Du in `10_promises/solution`
- Wenn Du fertig bist, bitte die Hand in Zoom heben 🙋
                      </code></pre>
        </section>

        <section id="t-typescript">
          <h2>TypeScript</h2>
          <p class="fragment">
            <em>TypeScript is a superset of JavaScript that compiles to plain JavaScript </em>(
            <a href="http://www.typescriptlang.org/" target="_blank"
              >http://www.typescriptlang.org/</a
            >)
          </p>
          <ul>
            <li class="fragment">Erweitert JavaScript um ein Typen System</li>
            <li class="fragment">
              Jeder gültige JavaScript Code ist auch gültiger TypeScript Code
            </li>
            <li class="fragment">
              Mittels des TypeScript Compilers wird aus TS Code JavaScript Code
            </li>
            <li class="fragment">
              TypeScript-spezifischer Code ist nach dem Compilieren weg, Laufzeitverhalten
              unterscheidet sich daher nicht von JavaScript
            </li>
          </ul>
        </section>

        <section>
          <h3>TypeScript Grundlagen</h3>
          <p>Typ-Angaben werden hinter einen Bezeichner geschrieben</p>
          <pre class="fragment"><code class="typescript line-numbers" contenteditable data-trim>
// Variablen können Typ-Informationen bekommen
let foo: string;
foo = 'yo';
// Error: number: This type is incompatible with string
foo = 10;
         </code></pre>
          <pre class="fragment"><code class="typescript line-numbers" contenteditable data-trim>
// Funktionen
function sayIt(what: string): string {
return `Saying: ${what}`;
}

sayIt('Klaus'); // ok
sayIt(10); // error
</code></pre>

          <pre class="fragment"><code class="typescript line-numbers" contenteditable data-trim>
// Arrow Funktionen
const sayIt = (what: string): string => `Saying: ${what}`;

sayIt('Moin');
sayIt(123); // Error: Argument of type '123' is not assignable
      // to parameter of type 'string'.
</code></pre>
        </section>

        <section>
          <h2>Eingebaute Typen</h2>
          <pre class="fragment"><code class="typescript line-numbers" contenteditable data-trim>
// string
let city: string = 'Hamburg';

// boolean
let isDone: boolean = false;

// number
let theAnswer: number = 42;

// array (note the [])
let cities: string[] = ['Hamburg', 'Barcelona'];
// alternative:
let languages: Array&lt;string> = ['JavaScript', 'TypeScript'];

// void
function log(s: string): void { /* ... */ }
      </code></pre>
        </section>
        <section>
          <h2>Eingebaute Typen: any und unknown</h2>
          <pre class="fragment"><code class="typescript line-numbers" contenteditable data-trim>
// any: kann alle Typen aufnehmen, Typ-Prüfung ist ausgeschaltet
let theUnknown: any = 'Who cares';
theUnknown = 666; // ok
theUnknown = true; // ok
let a: number = theUnknown; // ok

function loadData(): any { return "" // ok }
let b:number = loadData(); // ok

      </code></pre>
        </section>
        <section>
          <h2>Eingebaute Typen: any und unknown</h2>
          <pre class="fragment"><code class="typescript line-numbers" contenteditable data-trim>
// unknown: kann ebefalls alle Typen aufnehmen, erzwingt aber vor der Verwendung Typ-Prüfung
function loadData(): unknown { return "" // ok }
let b = loadData(); 
b.toUpperCase(); // ERROR
if (typeof b === "string") {
// b ist jetzt string (typeof ist Laufzeitprüfung!)
b.toUpperCase(); // OK
}
      </code></pre>
        </section>
        <section>
          <h2>Typen können abgeleitet (inferred) werden</h2>
          <pre class="fragment"><code class="typescript line-numbers" contenteditable data-trim>
let city = 'Hamburg'; // city ist ein String

city = 42;
// Fehler: [ts] Type '42' is not assignable to type 'string'.
</code></pre>
          <pre class="fragment"><code class="typescript line-numbers" contenteditable data-trim>
// Explizite Angabe eines Types (parameter)
// und abgeleiteter Typ (Return Type der Funktion)

function sayIt(what: string) {
return `Saying: ${what}`;
}

const said: string = sayIt('Hello TypeScript'); // ok
const saidItWrong: number = sayIt('Hello TypeScript'); // error!


</code></pre>
        </section>

        <section>
          <h2>Type Check ausschalten</h2>
          <p>
            Mit <code>@ts-ignore</code> (als Kommentar) kann wird die Überprüfung der nächsten Zeile
            ausgeschaltet:
          </p>
          <pre><code class="typescript line-numbers" contenteditable data-trim>
let city:string = "Hamburg";

city = 20259; // error: [ts] Type '20259' is not assignable to type 'string'.

// @ts-ignore
city = 20259; // ok                
</code></pre>
          <p class="fragment">
            Nützlich in corner cases, die nur schwer mit TypeScript abbildbar sind oder bei
            Migration
          </p>
        </section>
        <section>
          <h2>null und undefined</h2>
          <div class="fragment">
            <p><code>null</code> muss explizit zugelassen werden <em>(strictNullChecks</em>):</p>
            <pre><code class="typescript line-numbers" contenteditable data-trim>
let city:string = null; //Type 'null' is not assignable to type 'string'.

let optionalCity:string|null = null; // OK
      </code></pre>
          </div>
          <div class="fragment">
            <p><code>undefined</code> muss ebenfalls explizit zugelassen werden:</p>
            <pre><code class="typescript line-numbers" contenteditable data-trim>
let city:string = undefined; //Type 'undefined' is not assignable to type 'string'.

let optionalCity:string|undefined = undefined; // OK
let optionalCity:string|undefined|null = null; // OK
        </code></pre>
          </div>
          <div class="fragment">
            <p>
              Optionale Parameter können mit ? gekennzeichnet werden (erlauben dann auch
              <code>undefined</code>)
            </p>
            <pre class="fragment"><code class="typescript line-numbers" contenteditable data-trim>
function greet(name: string, greeting?: string) {
console.log(`${greeting || 'Hello'}, {name}`);
}

greet('Susi', 'Moin')// Moin, Susi

// 2. Parameter ist optional:
greet('Klaus'); // Hello, Klaus

greet('Peter', null); // Argument of type 'null' is not assignable
                // to parameter of type 'string | undefined'.
      </code></pre>
          </div>
        </section>

        <section>
          <h2>Eigene Typen</h2>
          <p>
            Mit <code>interface</code> und <code>type</code>können eigene Typen (Objekt-Strukturen)
            beschrieben werden:
          </p>

          <pre><code data-trim contenteditable class="line-numbers typescript" data-leftpad>
// Komplexer Typ
interface Person {
name: string; // Pflicht
livesIn?: string; // Optional
}

// Alternativ: Type Alias (interface und type fast synonym)
type Person = { name: string; livesIn?: string; }

const susi: Person = { // OK
name: 'Klaus',
livesIn: 'Hamburg'
};
const klaus: Person = { // OK (livesIn ist optional)
name: 'Klaus'
}

const helmut: Person = {} // Error: Property 'name' is missing

const lukas: Person = {
name: 'Lukas',
profession: 'Lokführer'
} // Error: 'profession' does not exist in type 'Person'.
         </code></pre>
        </section>

        <section>
          <h2>Eigene Typen II</h2>
          <p>Eigene Objekt-Typen können sowohl "Attribute" als auch Funktionen enthalten:</p>
          <pre><code data-trim contenteditable class="line-numbers typescript" data-leftpad>
    // Komplexer Typ
    type Person {
      name: string; // Pflicht
      greet(greeting: string): string;
    }

    const p:Person = {
      name: "Klaus",
      greet(greeting: string) { 
        return `${greeting}, ${this.name}`
      }
    }
    p.greet("Hello"); // OK
    p.greet(123); // ERR: Argument of type '123' is not 
                  // assignable to parameter of type 'string'.

    const wrong:Person = {
      name: "Susi", // OK
      greet(greeting: number) { return "hello" } 
        // ERR: Type '(greeting: number) => string' is not assignable to 
        //      type '(greeting: string) => string'.
        //      Types of parameters 'greeting' and 'greeting' are incompatible.
        //      Type 'string' is not assignable to type 'number'.
    }
                   </code></pre>
        </section>
        <section data-markdown>
          <textarea data-template>
### Intersection Types

* Intersection Types sind vorsichtig mit Vererbung in OO vergleichbar
* Ein Intersection Type enthält _alle_ Eigenschaften die in einem (oder mehreren Typen) vorhanden sind
* ```typescript
  const Person = { firstname: string }
  const Employee = Person & { company : string }

  const e: Employee = { firstname: "Klaus", company: "IT AG" }
  ```
---
### Intersection Types
* Der erzeugte Typen sind die Schnittmenge der angegebene Typen 
* ```typescript
  type A = { a: string }
  type B = { a: string | null }
  type C = A & B

  const c:C = {
    a: ""
  }

  const c2: C = {
    a: null // ERR: a ist string!
  }
  ```

* Das heißt auch, der Intersection Type kann jeweils seinen Typen zugewiesen werden.
* ```typescript

  declare function useA(a: A);
  declare function useB(b: B);

  useA(c);
  useB(c);
  ```
* Umgekehrt gilt das aber nicht:
* ```typescript
  declare function getB(): B;
  const result: C = getB(); 
  //      Types of property 'a' are incompatible.
  //        Type 'string | null' is not assignable to type 'string'.
  //          Type 'null' is not assignable to type 'string'
  ```
---
### Intersection Types  
* Wenn die Typen inkompatibel sind, ist das Ergebnis `never`:
* ```typescript
  type A = { a: string }
  type B = { a: boolean }
  type C = A & B

  const c:C = {
    a: "" // ERR: a ist never! 
  }
  ```

---
### Interface vs. Type

* Zum Beschreiben von Objekten könnt könnt ihr `Interface` und `Type` verwenden
* Die beiden Konstrukte sind sich sehr ähnlich
* In vielen Fällen macht es keinen Unterschied, abgesehen von minimal unterschiedlicher Syntax
* Die beiden Typen können sich auch gegenseitig erweitern
* ```typescript
  interface Person { name: string }
  type Employee = Person & { sallary: number }
  interface Manager extends Employee { bonus: number }
  ```
* Klassen können sowohl Types als auch Interfaces implementieren:
* ```typescript
  type Greeter = { sayHello(): string }
  interface Translator { translate(s: string): string }

  class Messenger implements Greeter, Translator {
    sayHello() { return "... "}
    translate(s: string) { return "..."}
  }
  ```
---
### Types und Interfaces: Unterschiede
* Mit `Type` definiert ihr einen Alias. Das geht nicht nur für Objekte
* ```typescript
  type OptionalString = string | null | undefined
  ```
* Mit `interface` könnt ihr nur Objekte beschreiben
* Die Deklarationen von zwei Interfaces mit demselben Namen werden zusammengeführt:
* ```typescript
  interface Person { name: string };
  interface Person { sallary: number };

  const person: Person = {
    name: "Klaus", sallary: 60000
  }
  ```
---
### "Duck Typing"  

* Für TypeScript sind zwei Typen identisch, wenn sie gleich aussehen
* ```typescript
  type Person = { name: string }
  function sayHello(p: Person) {
    // ...
  }

  sayHello({name: "Klaus"}); // OK, weil übergebenes Objekt
                             // "aussieht" wie Person
  ```
* Namen von Typen spielen (anders als in Java) keine Rolle:
* ```typescript
  type Person = { name: string };
  interface Animal { name: string, size?: number };

  const p: Person = { name: "Klaus" };
  const a: Animal = p; // OK: Animal ist kompatibel zu Person
                       // (size ist optional in Animal)

  ```

  
          </textarea>
        </section>
        <section data-markdown>
          <textarea data-template>
### Type Casts

* Genau wie in Java können Typen "gecastet" werden
* ```typescript
  declare function readObjectFromDatabase(): object;

  type Person = { firstname: string };

  const p: Person = readObjectFromDatabase() as Person;
  ```
* Wenn die Typen (für TypeScript) nicht kompatibel sind, müssen zwei Casts durchgeführt werden
(ebenfalls ähnlich wie in Java)
* ```typescript
  const person = {
    firstname: "Klaus"
  }

  const s:string = person; // ERR Type '{ firstname: string; }' is not assignable to type 'string'
  const a:string = person as string; // ERR Conversion of type '{ firstname: string; }' to type 'string' may be a mistake because neither type sufficiently overlaps with the other.
  const b:string = person as unknown as string; // OK ... 
  ```

  </textarea
          >
        </section>
        <section>
          <h2>Union Types</h2>
          <p>Variablen, Parameter etc. können mehr als einen Typ annehmen:</p>
          <pre><code data-trim contenteditable class="line-numbers typescript" data-leftpad>
type Person = { name: string };
type Movie = { title: string };

function printNameOrTitle(obj: Person | Movie) { 

console.log(obj.title); // ERR: Property 'title' does not 
                  // exist on type 'Person | Movie'

if ("title" in obj) { // Abfrage ist ein "Type Guard"
// obj ist Movie hier, title ist definiert
console.log(obj.title);
} else {
// obj ist Person hier: name ist definiert
console.log(obj.name);
}
}

printNameOrTitle({name: "Klaus"}); //OK
printNameOrTitle({title: "Pulp Fiction"}); //OK
printNameOrTitle({label: "Save"}); // ERR

  </code></pre>
        </section>
        <section>
          <h2>Type Guards</h2>
          <p>Durch einen Type Guard können Typen "eingeengt" werden</p>
          <pre><code data-trim contenteditable class="line-numbers typescript" data-leftpad>
type Person = { name: string };
type Movie = { title: string };

// Wenn diese Funktion true zurueckgibt, nimmt Typescript an,
// dass das übergebene Argument vom Typ Movie ist
function isMovie(candidate: any): candidate is Movie {
  return ("title" in candidate);
}

function printNameOrTitle(obj: Person | Movie) { 
  if (isMovie(obj)) {
    // movie
  }
}

  </code></pre>
        </section>
        <section data-markdown>
          <textarea data-template>
### Narrowing
* Mit einem Type Guard kannst Du Typen "einschränken"
  * Das Konzept nennt sich [Type Narrowing](https://www.typescriptlang.org/docs/handbook/2/narrowing.html)
* Es gibt verschiedene (JavaScript) Laufzeit-Prüfungen, aus denen TypeScript zur Build-Zeit Rückschlüsse auf das Typ-System zieht:
* Du kannst den `typeof`-Operator von JavaScript verwenden:
* ```typescript
  function sayHello(a: string | Function) {
    if (typeof a === "function") {
      // a ist hier Function
      return `Hello, ${a()}`
    }

    // a ist hier String
    return `Hello, ${a.toUppercase()}`
  }
  ```

* Mit `in` prüfen, ob eine Eigenschaft in einem Objekt vorhanden ist
* ```typescript
  type Person = { firstname: string, lastname: string, address: { street: string } }
  type Company = { name: string, address: { street: string } }

  function greet(a: Person | Company) {
    console.log(`You're at ${a.address.street}`); 
      // OK address.street in Person und Company vorhanden

    if ("firstname" in a) {
      console.log(`Hello ${a.firstname} ${a.lastname}`); 
    } else {
      console.log(`Company name ${a.name}`);
    }
  }
  ```
---
### Narrowing 2  
* Mit `instanceof` kannst Du prüfen, um welche Instanz einer Klasse es sich handelt  
* ```typescript
  class Person {}
  class Company {}
  function greet(p: Person | Company) {
    if (p instanceof Person) {
      // p ist Person hier
    } else {
      // p ist Company hier
    }
  }
  ```
* An Hand von konkreten Werten
* ```typescript
  type SuccessMessage = { success: true, msg: string };
  type ErrorMessage = { success: false, error: string };

  function handleMessage(m: SuccessMessage | ErrorMessage) {
    // 'success' in beiden Typen vorhanden, unterscheiden sich aber durch Ausprägung
    if (m.success === true) {
      // SuccessMessage
      return m.msg; // OK
    }
    return "Error: " + m.error; // OK
  }
  ```


  </textarea
          >
        </section>
        <section>
          <h2>Type Assertions</h2>
          <pre><code data-trim contenteditable class="line-numbers typescript" data-leftpad>
type Person = { name: string };
type Movie = { title: string };

// Wenn diese Funktion zurueckkehrt (kein Error geworfen wird) nimmt Typescript an,
// dass das übergebene Argument vom Typ Movie  ist
function assertIsMovie(candidate: any): asserts candidate is Movie {
  if ("title" in candidate) {
    return;
  }
  throw new Error("Candidate is not a movie!")
}

function printTitle(hopefullyAMovie: any) { 
  assertPersonIsMovie(hopefullyAMovie)
  // hopefullyAMovie ist jetzt Movie
  hopefullyAMovie.title; // OK
}

  </code></pre>
        </section>

        <section data-markdown>
          <textarea data-template>
### Literal Types
* Mit einem [Literal Type](https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#literal-types) kannst Du einen Typen definieren, der einen konkreten String darstellt 
* ```typescript
  // Beispiel:             
  type Answer = "Yes" | "No" | "I_dont_care";

  const a1:Answer = "Yes"; // OK
  const a2:View = "Maybe" // FEHLER
  ```
* ```typescript
  function fillIn(a: Answer) {
    if (a === "Yes") { ... } // ok
    if (a === "Maybe") { ... } // error: immer false
  }

  fillIn("I_dont_care"); //OK
  fillIn("Maybe"); // ERROR
  ```
* Das funktioniert auch für number 
* ```typescript
  type OneOrZero = 1 | 0;
  declare function toggleBit(v: OneOrZero): void;
  toggleBit(1); // OK
  toggleBit(2); // ERR
  ```  

---
### Der typeof-Operator

* Der `typeof`-Operator in JavaScript liefert den _Wert_ einer Variablen zur Laufzeit zurück.
* Mit dem [`typeof`-Operator von TypeScript](https://www.typescriptlang.org/docs/handbook/2/typeof-types.html#handbook-content) kann der Typ eines Werts auf Typ-Ebene ermittelt werden.
  * Im Grunde das, was die IDE tut, wenn ihr mit der Maus über einen Variable fahrt
* ```typescript
  const languages = {
    de: "DE",
    en: "EN"
  }

  type TLanguages = typeof languages;          // TLanguages ist TYPE, languages ist WERT
        // { de: string; en: string; }

  export declare function translateMessage(msg: string, lang: keyof TLanguages): string;

  // oder:
  type TLanguageKeys = keyof typeof languages;
  export declare function translateMessage(msg: string, lang: TLanguageKeys): string;
  ```
* Das geht für alle möglichen Dinge, auch für Funktionen:
* ```typescript
  declare function sayHello(name: string): string | null;

  type Fn = typeof sayHello;
        // (name: string) => string | null
  ```
---
### Übung: TypeScript
* Mach dich mit `typeof`, Union Types und Type Guards vertraut
* Vorbereitung:
  * Bitte in `js-intro/ts` einmal `npm install` ausführen
* In der Datei `js-intro/ts/10_intro.ts` findest Du eine Übung beschrieben
* Du musst die Datei nicht ausführen. Sie soll "nur" keine TypeScript-Fehler haben
* Die erwarteten Fehler (bzw. nicht-Fehler) habe ich Euch in die Datei geschrieben.
* Eine mögliche Lösung findest Du in `10_s_intro.ts` ("s" wie Solution 😊)
* Wenn Du fertig bist, bitte Hand heben in Zoom 🙋

---
## Generics
<!-- .slide: id="t-generics" -->

---
### Generics
* **Beispiel**: eine (JavaScript-)Funktion, die einen beliebigen Wert validiert. Wenn der Wert gültig ist,
wird er von der Funktion unverändert zurückgegeben, ansonsten wirft die Funktion einen `Error` und kehrt nicht zurück.
* Mit `any` können wir Funktionen beschreiben, die alle möglichen Typen entgegennehmen
  und/oder zurückliefern
  * ```typescript
    declare function validate(obj: any): any
    ```
* Was machen wir aber, wenn wir den übergebenen Typen (für `obj`) an anderer Stelle benötigen?
  * Zum Beispiel, um sicherzustellen, dass der Rückgabe-Typ dem Typen eines Parameters entspricht?
* ```typescript
  const p = validate("hallo"); // p soll string sein (ist: any 😔)
  const n = validate(123); // n soll number sein (ist: any 😔)
  ```
  
---
### Generics
* Für Funktionen, Klassen und Typen können **Typ Variablen** definiert werden
* Fast wie Funktionsparameter, nur dass keine __Werte__, sondern __Typen__ angegeben werden
* Die Typ Variable wird deklariert (`<VariablenName>`) und kann dann in der gesamten Funktionssignatur bzw. Typ-Definition verwendet werden
* Vorheriges Beispiel, jetzt mit Generics und gewünschtem Verhalten:
  * ```typescript
    // "O" ist Typ Variable

    declare function validate<O>(o: O): O
    const p = validate("hallo"); // p jetzt string 😊
    const n = validate(123); // n jetzt number 😊
    ```
---
### Generics: Weitere Beispiele    
* Fachliche Idee: Die **Funktion** liefert den übergebenen Wert zurück
  oder "null", falls der Wert ungültig ist (was auch immer "ungültig" hier bedeutet)  
* ```typescript
    declare function validate<O>(o: O): O | null
  ```
* Ein **Type Alias**, der entweder eine Liste von Dingen ist oder `null`
  * (fachlich bescheuertes Beispiel, bessere Beispiele folgen...)
* ```typescript
    type ListOrNull<O> = Array<O> | null;
  ```
* Eine **Klasse**, die eine Liste von Dingen enthält:
* ```typescript
  class OrderedList<O> {
    addItems(o: Array<O>) {
      // ...
    }
  }
  ```
    
---
### Generics
* Beim Verwenden wird der __Typ__ entweder vom übergebenen __Wert__ abgeleitet:
* ```typescript
  declare function validate<O>(o: O): O | null
  const x = validate("Hallo"); // O ist string, x ist string | null
  const y = validate(7); // O ist number, y ist number | null
  ```
* ...oder der Typ wird explizit angegeben. Dann muss der __Wert__ dem angegebenen __Typen__ entsprechen:
* ```typescript
  validate<string>("Hallo"); // O ist string, Argument ist string: Alles OK!
  validate<string>(7); // O ist string, Argument ist number:
                       // ERR: Argument of type 'number' is not assignable to parameter of type 'string'
  ```
* Dasselbe gilt für Klassen:
* ```typescript
  class OrderedList<O> {
    constructor(initialItems: Array<O>) {
      // ...
    }
  }

  new OrderedList<string>([ "A" ]); // OK 
  new OrderedList([ "A" ]); // OK
  new OrderedList<string>([ 1 ]); // ERR Type 'number' is not assignable to type 'string'.
  ```
  
---
### Generics: Default-Werte
* Analog zu "normalen" Funktionsargumenten, können auch bei Generics Default**typen** angegeben werden
* Wie bei Funktionsargumenten kann auch nur der letzte bzw. die letzten Argumente Default-Typen haben
* ```typescript
  declare function validate<O, R = string>(o: O): O | R

  validate(7); // RückgabeTyp: number | string 
  validate<number>(7); // RückgabeTyp: number | string 
  validate<number, null>(7); // RückgabeTyp: number | null
  validate<number, boolean>(7); // RückgabeTyp: number | boolean
  ```
* ```typescript
  type Tuple<X, Y = string> = [X, Y];

  type TupleOfNumberAndStrings = Tuple<number>; // [number, string]
  type TupleOfStringAndBoolean = Tuple<string, boolean>; // [string, boolean]
  ```
* Wie bei Funktionsargumenten, können auch Typ Variablen an andere Typen weitergegeben werden:
* ```typescript
  type ReactUseStateTuple<V> = Tuple<V, (newValue: V) => void>;
         // [ V, function(a: V): void ]
  ```

---
### Generic: Constraints   
* Wie bei "normalen" Argumente, können die Typ-Argumente Einschränkungen haben:
* Die Einschränkungen werden mit `extends` definiert
  * Der übergenene Typ muss dann derselbe oder ein davon erweiterter sein:
* Beispiel: beliebiges Objekt erlaubt  
* ```typescript
  declare function validateObject<O extends object>(o: O): O | null;

  validateObject({name: "Klaus"}); // OK
  validateObject("Klaus");         // ERR: Argument of type 'string' is not 
                                   // assignable to parameter of type 'object'

  ```
* Beispiel: nur Objekte mit bestimmter Struktur erlaubt  
* ```typescript
  type Person = { firstname: string | null };

  declare function getOrDefault<P extends Person>(p: P): P;

  getOrDefault( { } ); // ERR: Property 'firstname' is missing in type '{}' 
                       // but required in type 'Person'
  ```
---
### keyof
* [`keyof`](https://www.typescriptlang.org/docs/handbook/2/keyof-types.html) liefert einen Union Typen zurück, der alle Keys eines Objektes enthält
* ```typescript
  type Person = {
    firstname: string;
    lastname: string;
  }
  type PersonKeys = keyof Person; // "firstname" | "lastname"

  ```
* Damit kann man zum Beispiel erzwingen, das ein Funktionsparameter nur gültige
  Keys eines Objekts aufnehmen kann:
* ```typescript
  declare function logPropertyOfPerson(propName: keyof Person): void;

  logPropertyOfPerson("firstname"); // OK
  logPropertyOfPerson("age") // ERR: Argument of type '"age"' is not 
                              // assignable to parameter of type 'keyof Person'

  ```  
---
### Generics mit Union Typen  

* Wenn man einen Union Type als Constraint angibt, muss der übergebene Typ einem
  der im Union-Typen enthaltenen Typen entsprechen:  
* ```typescript
  type Color = "red" | "blue" | "green";

  declare function bgColor<C extends Color> (c: Color): { backgroundColor: C };

  bgColor("red"); // OK
  bgColor("white"); // Argument of type '"white"' is not 
                    // assignable to parameter of type 'Color'
  ```
* ```typescript
  type ListOfStringsOrBooleans<X extends string|boolean> = Array<X>;

  const c1: ListOfStringsOrBooleans<string> = ["a"]; // Ok
  const c2: ListOfStringsOrBooleans<boolean> = [true]; // Ok
  const c3: ListOfStringsOrBooleans<string|boolean> = [true, "jo!"]; // Ok

  const c4: ListOfStringsOrBooleans<number> = [4]; // ERR Type 'number' does not satisfy 
                                                   // the constraint 'string | boolean'

  declare function validateNumberOrString<O extends string|number>(o: O): O | null    
  ```

---
### Übung Generics
* Beschreibe eine generische Wrapper-Klasse, die ein Objekt verwaltet
* Aufgabenbeschreibung findest Du in `29_uebung_generics.ts`.
* Die Lösung findest Du in `29_s_uebung_generics.ts` (`s` wie `solution
* Wenn Du fertig bist, bitte Hand heben in Zoom 🙋
  </textarea
          >
        </section>
        <section data-markdown>
          <textarea data-template>
### Decorators

* Ein "Dekorator" "dekoriert" ein bestehendes Objekt, eine Funktion oder eine Klasse und fügt neue Funktionalität hinzu
  * Typisches Pattern in vielen Programmiersprachen, kennen wir auch aus Java
  * Oftmals werden Dekoratoren für Querschnittsaufgaben verwendet (Logging/Monitoring/Tracing, Fehlerbehanlding, Transaktionen, Sicherheit)
* In JavaScript bzw. TypeScript gibt es mehrere Ansätze dafür:
  * "Normales" JavaScript verwenden
  * ```typescript
    function makeLoggingFunction(fn) {
      return (...args) => {
        try {
          console.log(`Function ${fn.name} with args ${args} invoked.`);
          return fn(...args);
        } finally {
          console.log(`Function ${fn.name} returned.`);
        }
      };
    };
    ```
  * ```typescript
    function sayHello(name) { console.log(`Hello, ${name}`) }

    const loggingSayHello = makeLoggingFunction(sayHello);
    loggingSayHello("Klaus");

    // Function sayHello with args ["Klaus"] invoked.
    // Hello, Klaus
    // Function sayHello returned.
    ```
---
### Decorators
* Es gibt ein [Proposal für Decorators](https://github.com/tc39/proposal-decorators) in JavaScript
* Das ist nicht final, ab Stage 3, d.h. es wird ziemlich sicher so umgesetzt
* TypeScript bietet jetzt schon (seit Version 5) Unterstützung dafür
  * Warnung 1: API und Verhalten kann sich prinzipiell noch ändern
  * Warnung 2: Das Proposal existiert seit fünf (!) Jahren und wurde zuletzt immer wieder geändert
    * TypeScript bietet auch Support für das "alte" Decorator Proposal [("Experimental Legacy Decorators")](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-5-0.html#differences-with-experimental-legacy-decorators)
    * Das muss explizit eingeschaltet werden
    * Ohne Flag `--experimentalDecorators` verwendet TypeScript den "neuen" Standard, mit dem Flag den alten
* Im folgenden gucken wir uns das aktuelle Proposal an
---
### JS Decorators
* Im aktuellen Proposal können damit JavaScript Klassen und ihre Member dekoriert werden
* Ein Dekorator ist eine beliebige Funktion mit der Signatur `(value, context)`
* Je nachdem, wo der Dekorator angewendet wird, wird der `value` gesetzt (z.B. eine Klasse, eine Funktion oder der Wert eines Felds)
* Der `context` gibt Auskunft darüber, wo und wie der Dekorator angewandt wurde
  * `name`: Name des Members
  * `kind`: Typ des Members (`class`, `field`, `method`, `getter`, `setter`)
  * Andere Informationen am `context` sind abhängig vom Typ des Members
* ```typescript
    function dump(value: any, context: DecoratorContext) {
      console.log([typeof value, context.kind, context.name]);
    }
    @dump
    class Person {
      @dump
      name = "Klaus"

      @dump
      sayHello() {
        return "..."
      }
    }
  ```
* ```typescript
  const p = new Person();
    // function, method, sayHello
    // undefined, field, name
    // function, class, Person
  ```
---
### Decorators: Parameter
* Die Typen der beiden Parameter und des Rückgabewertes sind abhängig, von der Stelle, an der der Dekorator verwendet wird
* Der `value`-Parameter enthält den Wert des Members, der dekoriert wurde
* Welche TypeScript-Typen ihr für `context` und `value` verwendet, hängt auch von der geplanten Verwendung des Dekorators ab
  * Oft pragmatisch, `any` zu verwenden
* Für `context` gibt es TS Typen, die in `lib.decorators.d.ts` definiert sind (noch nicht in der Dokumentation)
* ```typescript
  /**
  * The decorator context types provided to class element decorators.
  */
  type ClassMemberDecoratorContext =
    | ClassMethodDecoratorContext
    | ClassGetterDecoratorContext
    | ClassSetterDecoratorContext
    | ClassFieldDecoratorContext
    | ClassAccessorDecoratorContext
    ;

  /**
  * The decorator context types provided to any decorator.
  */
  type DecoratorContext =
    | ClassDecoratorContext
    | ClassMemberDecoratorContext
    ;
  ```

  * Wollt ihr z.B. sicherstellen, dass ein Dekorator nur für Felder verwendet werden kann, verwendet ihr `ClassFieldDecoratorContext`
  * Ansonsten `DecoratorContext` oder Union-Typ mit den unterstützen Typen
    * Dann könnt ihr über `context.kind` zur Laufzeit prüfen, wie bzw. wo der Dekorator verwendet wurde
    * Die Prüfung dient als Type Guard:
    * ```typescript
      function log(value: any, ctx: ClassMemberDecoratorContext) {
        if (ctx.kind === "field") {
          // ctx hier ClassFieldDecoratorContext
        } else if (ctx.kind === "method") {
          // ctx hier ClassMethodDecoratorContext
        }
      }
      ```
  
---
### Decorators an Feldern

* Der `value` ist bei Felder immer `undefined`
* Um den Wert zu lesen oder zu verändern, muss der Dekorator eine `initalizerFunction` zurückliefern
* Diese Funktion bekommt den initialen Wert (wie in der Deklaration angegeben) übergeben und
kann einen neuen Wert zurückliefern
* ```typescript
  function increase(value: undefined, ctx: ClassFieldDecoratorContext) {
    return (initialValue: any) =>
      typeof initialValue === "number" ? initialValue + 1 : initialValue;
  }

  class Person {
    @increase
    age: 32

    @increase
    name: "Klaus"
  }

  const p = new Person();
  p.age; // 33
  p.name; // Klaus
  ```
---
### Decorator an Methoden
<!-- .slide: class="left" -->
* Bei Dekoraten an Methoden ist der `value` eine `Function`
* `kind` am `context` ist `method`
* Der Dekorator kann eine neue Funktion zurückliefern. 
  * Diese Funktion überschreibt dann die ursprüngliche Funktion
  * ```typescript
    function trace(value: Function, ctx: ClassMethodDecoratorContext) {
      return (...args: any) => {
        try {
          console.log(`Method ${String(ctx.name)} with args ${args} invoked.`);
          return value(...args);
        } finally {
          console.log(`Method ${String(ctx.name)} returned.`);
        }
      };
    }
  ```
  * ```typescript
    class Person {
      @trace
      sayHello(name: string) { console.log("Hello", name) }
    }
    ```
  * ```typescript
    new Person().sayHello("Klaus"); 
      // Method sayHello with args Klaus invoked
      // Hello, Klaus
      // Method sayHello returned.
    ```
* Achtung! Method-Dekoratoren gelten nicht für `get` bzw. `set`-Methoden!
* ```typescript
  class Person {
    @trace // ERR: Type '"getter"' is not assignable to type '"method"'
    get age() { return 32 }
  }
  ```
---
### Dekoratoren für getter und setter
* Für Accessor-Methoden ("getter" bzw. "setter") gibt es jeweils eigene Dekorator-Typen
* Diese bekommen als `value` die getter- bzw- setter-Methode übergeben
* `kind` in `context` ist `"getter" bzw. `"setter"` 
* Zurückgeliefert werden kann eine neue getter- oder setter-Funktion
* Die Original-Funktion muss mit `call` aufgerufen werden, um das `this`-Objekt
  korrekt zu setzen!
* ```typescript
  function uppercaseOnly(setter: Function, ctx: ClassSetterDecoratorContext) {
    return function uppercaseSetter(this: any, args: any) {
      // this hier die Instanz der Klasse
      if (typeof args === "string") {
        return setter.call(this, args.toUpperCase());
      }
      return setter.call(this, args);
    };
  }
  ```
* ```typescript
  class Person {
    #name;

    @uppercaseOnly
    set name(n: string) {
      this.#name = n;
    }
    get name() { return this.#name; }
  }

  const p = new Person();
  p.name = "Klaus";
  console.log(p.name); // KLAUS
  ```
  

---
### Decorator Factories

* Ihr könnt als Dekorator nicht nur eine _Funktion_, sondern auch einen _Funktionsaufruf_ hinschreiben
* In diesem Fall muss dann der Funktionsaufruf die Dekorator-Funktion zurückliefern
* Damit könnt ihr "Factories" für Dekoratoren bauen, die z.B. zusätzliche Parameter entgegennehmen
* ```typescript
  function traceLevel(level: "warn" | "info" | "debug") {
    return function traceDecorator(value: Function, ctx: ClassMethodDecoratorContext) {
      return (...args: any) => {
        try {
          console[level](`Method ${String(ctx.name)} with args ${args} invoked.`);
          return value(...args);
        } finally {
          console[level](`Method ${String(ctx.name)} returned.`);
        }
      };
    };
  }
  ```
* ```typescript
  class Person {

    @trace("warn")
    sayHello() { }

    @trace("debug")
    greet() { } 
  }
  ```
* ```typescript
  const p = new Person();
  p.sayHello(); // Ausgabe in Dekorator auf console.warn  
  p.greet(); // Ausgabe in Dekorator auf console.debug  
  ```
    
  

  
          </textarea>
        </section>

        <section>
          <h2>Geschafft! 😊</h2>
          <h3>Vielen Dank für Eure Teilnahme!</h3>
          <h3>Viel Spaß und Erfolg weiterhin!</h3>
          <p>Wenn ihr noch Fragen habt, könnt ihr mich erreichen:</p>
          <p>Mail: <a href="mailto:nils@nilshartmann.net">nils@nilshartmann.net</a></p>
          <p>
            Web: <a href="https://nilshartmann.net" target="_blank">https://nilshartmann.net</a>
          </p>
          <p>
            Twitter: <a href="https://twitter.com/nilshartmann" target="_blank">@nilshartmann</a>
          </p>
        </section>
      </div>
    </div>

    <script src="slides/revealjs/reveal.js/dist/reveal.js"></script>
    <script src="slides/revealjs/reveal.js/plugin/notes/notes.js"></script>
    <script src="slides/revealjs/reveal.js/plugin/markdown/markdown.js"></script>
    <script src="slides/revealjs/reveal.js/plugin/highlight/highlight.js"></script>
    <script src="slides/revealjs/config.js"></script>
  </body>
</html>
