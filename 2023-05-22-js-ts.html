<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />

    <title>JS/TS Training</title>

    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui"
    />
    <link rel="stylesheet" href="slides/revealjs/reveal.js/dist/reset.css" />
    <link rel="stylesheet" href="slides/revealjs/reveal.js/dist/reveal.css" />
    <link rel="stylesheet" href="slides/revealjs/reveal.js/dist/theme/solarized.css" />

    <!-- Theme used for syntax hislides/ghlighted code -->
    <link rel="stylesheet" href="slides/revealjs/highlight-js-github-theme.css" />
    <link rel="stylesheet" href="slides/revealjs/styles.css" />
  </head>

  <body>
    <div class="reveal">
      <!-- Any section element inside of this container is displayed as a slide -->
      <div class="slides">
        <section data-state="title">
          <h2 class="title" style="font-size: 7rem">
            <b>JavaScript &amp; TypeScript Workshop</b>
          </h2>

          <h4>
            <span class="transparent-bg">
              <a href="https://nilshartmann.net" target="_blank">Nils Hartmann</a>
              |
              <a href="https://twitter.com/nilshartmann" target="_blank">@nilshartmann</a>
            </span>
          </h4>

          <div>
            <h3 style="margin-top: 4rem"><span class="transparent-bg">Repository</span></h3>
            <p>
              <span class="transparent-bg">https://github.com/nilshartmann/js-ts-training</span>
            </p>
            <h3 style="margin-top: 4rem"><span class="transparent-bg">Slides</span></h3>
            <p>
              <span class="transparent-bg">Lokal: 2023-05-22-js-ts.html</span>
            </p>
            <p>
              <span class="transparent-bg"
                >Remote:
                <a href="https://nilshartmann.github.io/js-ts-training/2023-05-22-js-ts.html"
                  >https://nilshartmann.github.io/js-ts-training/2023-05-22-js-ts.html</a
                ></span
              >
            </p>
          </div>
        </section>
        <section>
          <h2>Nils Hartmann</h2>
          <p style="margin-top: 2rem">
            <a href="https://nilshartmann.net" target="_blank">https://nilshartmann.net</a>
            /
            <a href="https://twitter.com/nilshartmann" target="_blank">@nilshartmann</a>
          </p>
          <p style="margin-top: 2rem">
            <em>Freiberuflicher Software-Entwickler, Berater und Trainer aus Hamburg</em>
          </p>
          <p></p>
          <p style="margin-top: 5rem">Java | JavaScript, TypeScript | React | GraphQL</p>
          <div style="display: flex; justify-content: center; margin-top: 2rem">
            <div style="margin-left: 15px">
              <a href="https://graphql.schule/video-kurs"
                ><img
                  style="max-height: 450px"
                  src="slides/images/screenshot-graphql-kurs.png"
                /><br />https://graphql.schule/video-kurs</a
              >
              <br />
            </div>
            <!--  -->
            <div style="margin-left: 100px">
              <a href="https://reactbuch.de"
                ><img
                  style="max-height: 450px"
                  src="slides/images/react-buch-v2.jpg"
                /><br />https://reactbuch.de</a
              >
              <br />
            </div>
          </div>
        </section>

        <section>
          <h2>Und ihr?</h2>
          <ul>
            <li>Stellt euch doch bitte kurz vor...</li>
            <li>
              Eure Vorkenntnisse in <b>JavaScript</b>, <b>TypeScript</b>, <b>Node</b> bzw.
              Web-Frameworks und/oder Programmiersprachen?
            </li>
            <li>W√ºnsche f√ºr diese Schulung? Besondere Themen oder Interessen?</li>
          </ul>
        </section>

        <!-- ============================================================================= -->
        <section>
          <h2>Grunds√§tzliches</h2>
          <p><b>Jederzeit:</b> Fragen und Diskussionen!</p>
          <p class="fragment">Bitte schaltet Euer Video ein üôè</p>
          <p class="fragment">Motto: Es gibt keine dummen Fragen!</p>
          <p class="fragment">
            Bemerkbar machen per Audio, Chat oder Zoom Reaktion "Hand erheben"
            <span class="fragment"
              ><img width="50%" src="slides/images/zoom-reaktionen.png"
            /></span>
          </p>

          <p class="fragment">
            Ich zeige viel direkt im Editor, aber ihr k√∂nnt die Slides als Referenz benutzen
          </p>
          <p class="fragment">
            Wir machen zwischendurch √úbungen, in denen ihr selbst programmieren k√∂nnt
          </p>
        </section>

        <section data-markdown>
          <textarea data-template>
### Zeitplan
* 22. / 23. Mai
* Jeweils 8:30 Uhr bis 16:00 Uhr, jeweils derselbe Zoom-Link
* Mittagspause: 12:00 bis 13 Uhr üçï üçù
  * K√ºrzere Pausen zwischendurch ‚òïÔ∏è üò¥
          </textarea>
        </section>

        <section id="t-javascript">
          <h1>JavaScript</h1>
        </section>
        <section>
          <h3>Bevor wir loslegen...</h3>
          <p class="fragment">
            Wer f√ºhlt sich so, wenn wir √ºber JavaScript "Programmierung" sprechen? üôã‚Äç‚ôÄÔ∏èüôã‚Äç‚ôÇÔ∏è
          </p>

          <a href="https://twitter.com/lukaseder/status/787216648642109441">
            <img
              class="fragment"
              style="height: 1000px"
              src="slides/images/screenshot-tweet-the-javascript.png"
            />
          </a>
        </section>
        <section>
          <h3>JavaScript: Die Sprache</h3>
          <p>
            ‚ö†Ô∏è&nbsp;<em
              >JavaScript wurde in nur
              <a
                href="https://thenewstack.io/brendan-eich-on-creating-javascript-in-10-days-and-what-hed-do-differently-today/"
                >zehn Tagen</a
              ></em
            >&nbsp;erschaffen! üë∑
          </p>
        </section>

        <section>
          <h3>JavaScript: Dokumentation</h3>
          <p>
            <em> Documenting web technologies, including CSS, HTML, and JavaScript, since 2005.</em>
          </p>
          <p>üëâ <a href="https://developer.mozilla.org">https://developer.mozilla.org</a></p>
        </section>

        <section data-markdown>
          <textarea data-template>
### JavaScript: Dynamisches Typsystem

* In JavaScript haben Variablen _Typen_ (wie in Java)
  *  `boolean`, `number`, `bigint`, `string`, `object`, `null`, `undefined` und `symbol`
* JavaScript hat ein **dynamisches** Typ-System (im Gegensatz zu Java/C#/C++ etc.)
  * Der Typ einer Variable kann sich deswegen jederzeit √§ndern (ohne Type-Cast o.√§.)
  * ```typescript
    // let creates a variable
    let x = "Hallo"; // Typ von x ist string

    // dynamic typing (vs static typing in C#, java, ...)
    x = 7; // Typ von x === "number"
    x = false; // Typ von x === "boolean"

    x = function() { return "Hallo" } // ...

    x.toUpperCase(); // Ouch üò±
    ```
---
### JavaScript: Dynamisches Typsystem

* Das Typsystem ist au√üerdem **schwach**, d.h. es werden bei Bedarf automatisch Typ-Konvertierungen durchgef√ºhrt:
* ```typescript
  const a = 100;
  const b = true
  const c = a + b; // 101 ü•≥
  ```
* ```typescript
  const d = true + true + false; // 2 ü•≥ ü•≥
  ```
* ```typescript
  const e = false + null + []; // 0 üòµ‚Äçüí´
  ```
* Das d√ºrfte einer der Gr√ºnde sein, warum JavaScript bei vielen sehr beliebt üòç, von anderen geradezu gehasst üò° wird.
* Dazu sp√§ter mehr  
---
### TypeScript: statisches Typsystem

* TypeScript ist "JavaScript plus statisches Typsystem"
* Das bedeutet: 
  * vollst√§ndige JavaScript-Syntax ist auch in TypeScript g√ºltig
  * jeder g√ºltige JavaScript-Code ist g√ºltiger TypeScript Code
* TypeScript f√ºgt "nur" ein statisches Typsystem 
  * dazu erweitertes die Syntax von JavaScript um die M√∂glichkeit, Typen anzugeben
* Das Laufzeit-Verhalten von JavaScript und TypeScript ist identisch
  * denn: der TypeScript-Code (Typ-Annotationen) wird beim Compilieren komplett entfernt
  * (mit einer kleinen Ausnahme, den enums)
* Historisch hat(te) TypeScript noch mehr Features, die spielen aber praktisch keine Rolle mehr
  * Klassen z.B. gibt's jetzt auch in JavaScript
---
### TypeScript: implizite und explizite Typen

---
###
  
          </textarea>
        </section>
        <!-- ============================================================================= -->
        <section>
          <h3>Control flow</h3>
          <p>√Ñhnlich wie C#/Java</p>
          <p>if / else</p>
          <p>switch / case / default</p>
          <p>while / do</p>
          <p>break / continue</p>
          <p>try / catch</p>
          <p>Semikolon optional</p>
          <p>
            <a
              href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Control_flow_and_error_handling"
              >Referenz</a
            >
          </p>
        </section>
        <!-- ============================================================================= -->
        <section>
          <h3>Variablen: let und const</h3>

          <pre class="fragment"><code class="javascript">
            // Variable
            let alter = 42;
            alter = 43; // OK
          </code></pre>
          <pre class="fragment"><code class="javascript">

            // Konstante
            const name = "Susi";
            name = "Klaus"; // TypeError: invalid assignment to const 'name'
          </code></pre>

          <p class="fragment">Das veraltete <code>var</code> bitte <b>nicht mehr verwenden</b>!</p>
        </section>

        <!-- ============================================================================= -->
        <section>
          <h3>Operatoren</h3>
          <pre><code class="javascript">
// === (triple equal operator) OHNE implizite Typ-Konvertierung
if (42 === 42) {
  console.log("of course"); // of course
}
if ("3" === 3) {
  console.log("makes sense"); //
}

if ("" === false) {
  console.log("hmm..."); //
}
            </code></pre>
          <pre class="fragment"><code class="javascript">
// == (double equal operator) mit impliziter Typ-Konvertierung
// ("coercion")
if (42 == 42) {
  console.log("of course"); // of course
}
if ("3" == 3) {
  console.log("makes sense"); // makes sense
}
if ("" == false) {
  console.log("hmm..."); // hmm...
}
          </code></pre>

          <p class="fragment"><b>Empfehlung</b>: immer triple-equal-operator verwenden!</p>
          <p class="fragment">
            Mehr Spa√ü mit type coercion:
            <a href="https://github.com/denysdovhan/wtfjs">WTF JS</a>
          </p>
        </section>

        <!-- ============================================================================= -->
        <section>
          <h3>JavaScript: Datentypen</h3>

          <p>boolean, null, undefined, number, string, symbol, bigint</p>

          <p>Diese Typen gibt es auch genauso in TypeScript</p>

          <pre><code class="javascript">
            // typeof liefert den Typ einer Variable als String zur√ºck
            console.log(typeof 123); // "number"
          </code></pre>

          <pre class="fragment"><code class="javascript">
              const check = true; // typeof check === "boolean"
              if (check) {
                console.log("jupp!");
              }
            </code></pre>

          <pre class="fragment"><code class="javascript">
              const age = 32; // typeof age === "number"
              if (age < 16) {
                console.log("No Beer, sorry!")
              }
            </code></pre>

          <pre class="fragment"><code class="javascript">
              const name = "Klaus"; // typeof name === "string"
              if (name === "Klaus") { 
                console.log("Hello, Klaus!");
              }
            </code></pre>

          <pre class="fragment"><code class="javascript">
              let value;
              typeof value === "undefined"

              value = null;
              typeof value !== "undefined"
              typeof value === "???"

            </code></pre>
        </section>
        <!-- ============================================================================= -->
        <section>
          <h3>Template Strings</h3>
          <pre class="fragment"><code class="javascript">

const name = "Susi";

// Template String (with ``)
const greet = `Hello, ${name}`; // Hello, Susi

const loudGreet = `Hello, ${name.toUpperCase()}` // Hello, SUSI

// Zeilenumbr√ºche bleiben erhalten:      
const letter = `Hello, ${name},

thanks for subscribing to our e-mail newsletter.

Yours, Edgar`;       
          </code></pre>
        </section>

        <!-- ============================================================================= -->
        <section data-markdown>
          <textarea data-template>
<!-- .slide: class="left" -->            
### Funktionen
* ```typescript
  function greet(msg) {
    return "Hello, " + msg;
  }

  greet("World"); // Hello, World
  greet(null), // Hello, null
  greet(); // Hello, undefined
  ```
* Eine Funktion in JavaScript kann mit beliebigen Paramtern aufgerufen werden
  * unabh√§ngig davon, wieviele und welche Parameter sie deklariert hat
* In **TypeScript** _m√ºssen_ Funktionsparamter mit einer Typ-Annotation versehen werden
  * Dann ist nur ein "korrekter" Aufruf der Funktion m√∂glich
* ```typescript
  function greet(msg: string) { ... }

  greet("hello"); // OK
  greet(null); // ERR
  greet(); // ERR
  ```  
---
<!-- .slide: class="left" -->            
### Funktionen  
* Funktionen sind "1st-class-citizens" in JavaScript und ben√∂tigen keine Klasse o.√§.,
sondern k√∂nnen √ºberall hingeschrieben werden  
  * Genau wie bei anderen Werten k√∂nnen sie auch an Variablen zugeordnet oder als Parameter √ºbergeben werden
* ```typescript
  function greet(msg) { ... }

  const greetSomeone = greet;
  typeof greetSomeone; // "function"

  greetSomeone("World"); // Hello, World
  ```
* ```typescript
  // Referenzen auf Funktionen k√∂nnen als Parameter √ºbergeben werden
  function printer(getMessageFn) {
    console.log(getMessageFn())
  }

  // "inline" Funktion
  printer(function() { return "Hello, World"} );

  function helloWorld() { return  "Hello, World" };
  printer(helloWorld);
  ```
* √úbergebene Funktionen werden oft auch als **Callback-Funktionen** bezeichnet
  * In **Java** w√ºrde man daf√ºr ein (funktionales) Interface verwenden  


</textarea
          >
        </section>
        <section>
          <h3>Pfeilfunktionen (Arrow Functions)</h3>
          <p>In vielen F√§llen "nur" andere Schreibweise als <code>function</code></p>
          <pre><code class="javascript">
  const greet = (msg) => {
    return "Hello, " + msg;
  }
</code></pre>
          <pre class="fragment"><code class="javascript">
  // Bei genau einem Parameter kann die Klammer weggelassen werden:
  const greet = msg => { return "Hello, " + msg }
</code></pre>
          <pre class="fragment"><code class="javascript">
  // Bei keinem oder mehr als einem Parameter muss die Klammer gesetzt werden:
  const greet = (phrase, msg) => { return phrase + msg }
  const greetWorld = () => { return "Hello, World" };

</code></pre>
          <pre class="fragment"><code class="javascript">
  // bei genau einem Ausdruck, k√∂nnen geschweifte Klammern weggelassen werden:
  //   Ergebnis des Ausdrucks dann der R√ºckabgewert der Funktion:
  const greet = msg => "Hello, " + msg;
</code></pre>
          <pre class="fragment"><code class="javascript">
  // Verhalten wie "normale Funktion"
  greet("World"); // Hello, World
  greet(null), // Hello, null
  greet(); // Hello, undefined

  </code></pre>
        </section>
        <!-- ============================================================================= -->
        <section>
          <h3>Funktionen: Default-Parameter</h3>

          <pre class="fragment"><code class="javascript">
            function add(value, inc = 1) { ... } 
          </code></pre>

          <p class="fragment">
            Der Default-Parameter greift immer, wenn f√ºr den Parameter
            <code>undefined</code> √ºbergeben wurde:
          </p>

          <pre class="fragment"><code class="javascript">
            add(1); // entspricht: add(1,1)
          </code></pre>
          <pre class="fragment"><code class="javascript">
            add(1,undefined); // entspricht: add(1,1)
          </code></pre>
          <pre class="fragment"><code class="javascript">
            add(1,2); // entspricht: add(1,2);
          </code></pre>
          <pre class="fragment"><code class="javascript">
            add(1, null); // entspricht; add(1, null);
          </code></pre>
          <pre class="fragment"><code class="javascript">
            add(); // entspricht: add(undefined, 1);
          </code></pre>

          <p class="fragment">
            Mehrere Default-Parameter: danach d√ºrfen keine nicht-Default-Parameter kommen!
          </p>

          <pre class="fragment"><code class="javascript">
            function add(value, inc = 1) { ... } // ok
            function add(value = 0, inc = 1) { ... }  // ok

            function add(value = 0, inc) { ... } // FEHLER
          </code></pre>
        </section>
        <section>
          <h3>Rest-Parameter</h3>

          <p class="fragment">
            <a
              href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/rest_parameters"
              >Rest-Parameter</a
            >
            nehmen alle verbleibenen, √ºbergebenen Parameter auf
          </p>

          <pre class="fragment"><code class="javascript">
            function greet(phrase, ...names) { 
              // ...
            }

            greet("Hello", "World", "Peter", "Susi");

            // phrase ist "Hello",
            // names ist ein Array mit "World", "Peter", "Susi"
          </code></pre>

          <pre class="fragment"><code class="javascript">
            function say(...words) { 
              // ...
            } 

            say("One", "Two");

            // words ist ein Array mit allen Parametern ("One", "Two")
          </code></pre>
        </section>

        <!-- ============================================================================= -->
        <section>
          <h3>Funktionen</h3>
          <p>
            Achtung, return-Anweisung: Ergebnis direkt hinter das <code>return</code>-Keyword
            schreiben:
          </p>

          <pre class="fragment"><code class="javascript">
              function hello() {
                return "Hello";
              }
              const h = hello(); // "Hello"
            </code></pre>
          <pre class="fragment"><code class="javascript">

              function goodbye() {
                return 
                  "Goodbye";    // oh no üò¢!
              }

              const g = goodbye(); // undefined
            </code></pre>

          <pre class="fragment"><code class="javascript">
            // oder:
              function hello() {
                return (
                  "Hello"
                );
              }
            </code></pre>
        </section>

        <!-- ============================================================================= -->
        <section>
          <h2>√úbung: Strings und Funktionen</h2>
          <p>
            <em>Mache dich mit den JavaScript-Grundlagen vertraut</em>
          </p>

          <p class="fragment">
            Die Beschreibung der √úbung findest Du in
            <b><code>js-intro/01_basic/index.js</code></b
            >. Darin kannst Du auch deinen Code schreiben.
          </p>
          <p class="fragment">
            Du kannst die Datei mit <code>node index.js</code> von der Konsole ausf√ºhren.
          </p>
          <p class="fragment">Ausgaben erfolgen auf der Konsole.</p>
          <p class="fragment">Bei Fragen oder Problemen, kannst Du dich jederzeit melden</p>
          <p class="fragment">
            Wenn alle Stricke rei√üen, findest Du eine m√∂gliche L√∂sung in:
            <code>js-intro/01_basic/solution/index.js</code>
          </p>
          <p class="fragment">Wenn Du fertig bist, bitte "Hand heben" in Zoom üôã‚Äç‚ôÄÔ∏è</p>
        </section>
        <!-- ============================================================================= -->

        <!-- ============================================================================= -->
        <section data-markdown>
          <textarea data-template>
### Array
* In JavaScript k√∂nnen Arrays alle m√∂glichen Werte und Typen gemischt enthalten
* ```typescript
  const empty = [];
  const dinge = [ "a", 123, { name: "Klaus"}, false];
  ```
* In TypeScript k√∂nnen wir festlegen, welche Typen in einem Array enthalten sein d√ºrfen:
* ```typescript
  const names: Array<string> = ["Klaus", "Susi"];
  
  // oder:
  const names: string[] = ["Klaus", "Susi"];
  ```
* Ein bestehendes Array um neue Eintr√§ge erweitern
* ```typescript
  const abc = ["a", "b", "c"];

  abc.push("d", "e"); // ["a", "b", "c", "d", "e"]; // 5

  abc[4]; // e
  abc.length // 5
  ```
* Ein bestehende Array Kopieren und die Kopie erweitern
* ```typescript
  const three = [1, 2, 3];
  const five = three.concat(4, 5)
  // three !== five 
  ```

          </textarea>
        </section>

        <section>
          <h3>JavaScript: Arrays</h3>
          <pre><code class="javascript">
            const fruits = ["apple", "orange"];
          </code></pre>
          <pre class="fragment"><code class="javascript">
            // Iterieren
            for (const f of fruits) {
              console.log(f);
            }
            // "apple"
            // "orange"
  
            fruits.forEach(f => console.log(f));
            // "apple"
            // "orange"
          </code></pre>
          <pre class="fragment"><code class="javascript">
          // Transformieren ("map") eines Arrays

          const bigFruits = fruits.map(v => v.toUpperCase());
          // ["APPLE", "ORANGE"]
          </code></pre>
        </section>

        <!-- ============================================================================= -->
        <section>
          <h3>Objekt</h3>
          <p>Objekte werden als Literal in Form von Key-Value-Paaren geschrieben</p>
          <p>Wir brauchen f√ºr Objekte in JavaScript keine Klassen o.√§. (so wie in Java)</p>
          <pre><code class="javascript">
const firstname = "Klaus";

const person = {
  firstname: firstname,
  hobby: "Singing",
  age: 32
}

console.log(typeof person); // "object"
          </code></pre>
          <pre class="fragment"><code class="javascript">
// Auf Properties zugreifen
person.firstname // Klaus

// Zugriff via Index Notation
person["firstname"]; // Klaus
          </code></pre>
          <pre class="fragment"><code class="javascript">
// Werte zuweisen
person.firstname = "Susi"
          </code></pre>
          <pre class="fragment"><code class="javascript">
// Neues Property hinzuf√ºgen
person.livesIn = "Hamburg"

// Property entfernen
delete person.livesIn;

// Zugriff auf nicht vorhandenes Property
person.livesIn // undefined
                      </code></pre>
        </section>

        <!-- ============================================================================= -->
        <section>
          <h3>Objekte #2</h3>
          <p class="fragment">Object "Shorthand Notation"</p>
          <pre class="fragment"><code class="javascript">
            const firstname = "Klaus";
        
            const person = {
              firstname,
              hobby: "Singing",
              age: 32
            }
        </code></pre>

          <p class="fragment">Erinnerung: Nur Referenzen sind konstant!</p>

          <pre class="fragment"><code class="javascript">
            // Nur Referenzen sind konstant
            const person = {
              name: "Susi"
            }

            person = "Klaus"; // TypeError: invalid assignment to const 'person'
            person.name = "Klaus" // OK
          </code></pre>
        </section>

        <!-- ============================================================================= -->
        <section>
          <h2>√úbung: Arrays, Objekte und Funktionen</h2>

          <p class="fragment">
            Die Beschreibung der √úbung findest Du in
            <b><code>js-intro/02_objects_and_arrays/index.js</code></b
            >. Darin kannst Du auch deinen Code schreiben.
          </p>
          <p class="fragment">
            Du kannst
            <b><code>js-intro/02_objects_and_arrays/index.html</code></b> in deinem Browser √∂ffnen.
            Diese Datei f√ºhrt die <b><code>index.js</code></b
            >-Datei dann aus.
          </p>
          <p class="fragment">
            Ausgaben auf der Browser-Konsole, nach dem √Ñndern von <code>index.js</code>, die Seite
            im Browser neu laden
          </p>
          <p class="fragment">Bei Fragen oder Problemen, kannst Du dich jederzeit melden</p>
          <p class="fragment">
            Wenn alle Stricke rei√üen, findest Du eine m√∂gliche L√∂sung in:
            <code>js-intro/02_objects_and_arrays/solution/index.js</code>
          </p>
          <p class="fragment">Wenn Du fertig bist, bitte "Hand heben" in Zoom üôã‚Äç‚ôÄÔ∏è</p>
        </section>

        <!-- ============================================================================= -->
        <section>
          <h3>Objekte und Funktionen</h3>

          <p>Objekte k√∂nnen Funktionen enthalten</p>

          <pre><code class="javascript">
const person = {
  firstname: "Susi",
  sayHello() { return "Hello, " + this.firstname},
}

person.sayHello() // Hello, Susi
</code></pre>

          <p class="fragment">Warnung vor "this"!</p>
          <pre class="fragment"><code class="javascript">
const klaus = { 
  firstname: "Klaus", 
  sayHello: person.sayHello
};

klaus.sayHello() // ü§î
</code></pre>

          <pre class="fragment"><code class="javascript">
klaus.sayHello() // Hello, Klaus üòä
</code></pre>

          <pre class="fragment"><code class="javascript">
const sayHelloToSusi = person.sayHello;
sayHelloToSusi(); // ü§î
</code></pre>
          <pre class="fragment"><code class="javascript">
const sayHelloToSusi = person.sayHello;
sayHelloToSusi(); // Hello, undefined ü§™
</code></pre>
        </section>
        <section data-markdown>
          <textarea data-template>
### this-Binding in JavaScript

* In Java zeigt `this` immer auf die Instanz der Klasse, in der `this` verwendet wird
* Das ist in JavaScript nicht so!
* In JavaScript bestimmt der Aufrufer, auf was `this` zeigt. 
  * Man kann sich daher `this` wie einen impliziten, "unsichtbaren" Funktionsparameter vorstellen
* Das `this` bezieht sich in JavaScript auf das Objekt, an dem die Funktion aufgerufen wurde, nicht an dem sie definiert wurde!
* ```typescript
  const susi = {
    firstName: "Susi",
    getName() { return this.firstName }
  }
  susi.getName(); // Susi


  const klaus = { firstName: "Klaus" }
  klaus.getName = susi.getName;

  // 'this' zeigt hier auf das "klaus"-Objekt, nicht auf "susi"!
  klaus.getName(); // Klaus

  const getName = klaus.getName;
  // 'this' zeigt hier auf das globale Objekt (window im Browser)
  getName(); // undefined (globales Objekt hat kein 'firstname')
  ```


---
### Explizites this-Binding
* Ein konkretes `this` kann an eine Funktion explizit gebunden werden.
* Dann ist das `this` _immer_ das gebundene und kann von au√üen nicht mehr ver√§ndert werden
* Dazu wird mit `bind` eine neue Funktion erzeugt. In dieser ist das `this` dann gebunden
* ```typescript
  const p = { firstname: "Klaus", sayHello() { return this.firstname } }
  p.sayHello = p.sayHello.bind(p);

  p.sayHello(); // Klaus

  const s = { firstname: "Susi", sayHello: p.sayHello };
  s.sayHello(); // Klaus üëç 
  ```
* Mit `bind` kann jedes beliebige Objekt (oder `null` oder `undefined`) gebunden werden  
* ```typescript
  const person = { firstname: "Klaus" }
  const employee = { sayHello() { return this.firstname } }

  employee.sayHello(); // undefined (Kein 'firstname' in 'employee')

  employee.sayHello = employee.sayHello.bind(person);

  // this in sayHello zeigt nun auf person:
  employee.sayHello(); // "Klaus"
  ```
* Beim Aufrufen einer Funktion kann das `this` explizit f√ºr den Aufruf festgelegt werden
  * Dazu muss `call` bzw. `apply` verwendet werden. Der erste Parameter ist das `this`
  * ```typescript
    const person = { firstname: "Klaus", sayHello() { return this.firstname }};

    person.sayHello(); // Klaus
    person.sayHello.call({firstname: "Susi"}); // Susi
    ```

---
### Objekte und Pfeilfunktionen
* Pfeilfunktionen haben eine andere `this`-Strategie!
* Sie beziehen das `this` aus der Umgebung, in der sie *geschrieben* wurden
* Und das ist auch nicht √§nderbar!
  * weder mit `bind` noch mit `call` oder `apply`
* Daher eignen sich **nicht** oder nur bedingt f√ºr Methoden (also f√ºr Funktionen an Objekten):
* ```typescript
  const person = {
    firstname: "Susi",
    sayHello: () => { return "Hello, " + this.firstname }
  }

  person.sayHello();  Hello, undefined ü§™  
  ```
* In dem Fall ist `this` das globale this, das kein `firstname` Property hat

</textarea
          >
        </section>

        <!-- ============================================================================= -->
        <!-- ============================================================================= -->
        <section data-markdown>
          <textarea data-template>
### Mehr zu Objekten und Arrays            
          </textarea>
        </section>
        <section>
          <h3>Destructuring</h3>
          <p>
            Mit dem
            <a
              href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment"
              >object destructuring</a
            >
            Operator kannst Du Werte in einem Objekt an lokale Variablen zuweisen:
          </p>

          <pre><code class="javascript">
            // Ein Objekt...
              const person = {
                firstname: "Susi",
                lastname: "Meier",
                age: 32
              };
            </code></pre>
          <pre class="fragment"><code class="javascript">
              // Zugriff auf Properties (herk√∂mmlich)

              const firstname = person.firstname; // Susi
              const age = person.age; // 32
              const hobby = person.hobby; // undefined
            </code></pre>
          <pre class="fragment"><code class="javascript">
              // Zugriff auf Properties (Destrukturierung)

              const { firstname, age, hobby } = person;

              console.log(firstname); // Susi
              console.log(age); // 32
              console.log(hobby); // undefined
            </code></pre>
        </section>
        <section>
          <h3>Destructuring #2</h3>

          <p class="fragment"><em>Default Werte</em>:</p>

          <pre class="fragment"><code class="javascript">
              const person = {
                firstname: "Susi",
                age: 32
              };

              const { city = "Bonn" } = person;
              console.log(city); // Bonn
            </code></pre>
        </section>
        <section>
          <h3>Destructuring #3</h3>
          <p>Funktionsparameter, die ein Objekt sind, k√∂nnen destrukturiert werden:</p>

          <pre><code class="javascript">
              // Herk√∂mmlich
              function printPerson(person) {
                console.log(`${person.firstname} is ${person.age} years old`);
              }

              printPerson({ firstname: "Susi", age: 32 });
            </code></pre>

          <p class="fragment">Alternative mit Destrukturierung:</p>

          <pre class="fragment"><code class="javascript">
              function printPerson({firstname, age}) {
                console.log(`${firstname} is ${age} years old`);
              }

              printPerson({ firstname: "Susi", age: 32 });
            </code></pre>
        </section>
        <section>
          <h3>Destructuring #3</h3>
          <p>Mit Default-Wert</p>
          <pre><code class="javascript">
             function printPerson({name, age, city="Bonn"}) {
                 console.log(`${name}, ${age} years, lives in ${city}`);
             }
            </code></pre>
          <p class="fragment">ü§î Was wird hier ausgegeben? ü§î</p>
          <pre class="fragment"><code class="javascript">
             
              printPerson({name: "susi", age: 32});
            </code></pre>
          <pre class="fragment"><code class="javascript">
  
              printPerson({name: "susi", age: 32, city: "Freiburg"});
            </code></pre>
          <pre class="fragment"><code class="javascript">
  
              printPerson({name: "susi", age: 32, city: null});
            </code></pre>
          <pre class="fragment"><code class="javascript">
  
              printPerson({name: "susi", age: 32, city: undefined});
            </code></pre>
          <pre class="fragment"><code class="javascript">
  
              printPerson();
             </code></pre>
        </section>

        <section>
          <h3>Object Spread Operator</h3>

          <p>
            Mit dem
            <a
              href="https://developer.mozilla.org/de/docs/Web/JavaScript/Reference/Operators/Spread_syntax"
              >Spread Operator</a
            >
            k√∂nnen alle Felder eines Objektes an eine andere Stelle kopiert werden
          </p>

          <pre class="fragment"><code class="javascript">
            const person = { firstname: "Susi", age: 32 }
          </code></pre>
          <pre class="fragment"><code class="javascript">
            // Kopie erzeugen (herk√∂mmlich)
            const copy = { firstname: person.firstname, age: person.age } 

            // copy: { firstname: "Susi", age: 32}
          </code></pre>
          <pre class="fragment"><code class="javascript">
            // Kopie erzeugen (Spread operator)
            const copy = { ...person };

            // copy: { firstname: "Susi", age: 32}

            copy.age = 33;

            person.age; // 32
          </code></pre>

          <pre class="fragment"><code class="javascript">
            const person = { firstname: "Susi", age: 32 }

            const employee = { ...person, salary: 695000 }
            // employee: { firstname: "Susi", age: 32, salary: 695000 }
          </code></pre>
        </section>

        <!-- ============================================================================= -->
        <section>
          <h3>Destructuring und Spread mit Arrays</h3>
          <p>Beide Operatoren funktionieren auch mit Arrays:</p>

          <pre class="fragment"><code class="javascript">
            // Spread-Operator

            const cities = ["Hamburg", "Bonn"];
            const moreCities = [...cities, "K√∂ln"];
          </code></pre>

          <pre class="fragment"><code class="javascript">
            // Destructuring
            const cities = ["Hamburg", "Bonn", "K√∂ln"];
            const [hamburg, bonn] = cities;

            console.log(hamburg); // Hamburg
            console.log(bonn); // Bonn
          </code></pre>
        </section>

        <!-- ============================================================================= -->
        <!-- ============================================================================= -->
        <section>
          <h3>Truthy und falsy</h3>
          <p>
            <b><a href="https://developer.mozilla.org/de/docs/Glossary/Falsy">falsy</a></b> ist ein
            Wert, der <b>false</b> wird, wenn er (implizit oder explizit) in ein Boolean konvertiert
            wird
          </p>
          <p>
            <b><a href="https://developer.mozilla.org/de/docs/Glossary/Truthy">truthy</a></b> ist
            ein Wert, der <b>true</b> wird, wenn er (implizit oder explizit) in ein Boolean
            konvertiert wird (das sind alle Werte, die nicht falsy sind)
          </p>

          <pre><code class="javascript">
    if (true) { console.log("I'm true") } // I'm true

    if ("hello") { console.log("I'm true") } // I'm true
    
    if (null) { console.log("I'm falsy") } // 

    if (undefined) { console.log("I'm falsy") } // 
  </code></pre>

          <p class="fragment">Was ist mit diesen?</p>

          <pre class="fragment"><code class="javascript">
    if (0) { console.log("will this be shown?"); } // ü§î
  </code></pre>

          <pre class="fragment"><code class="javascript">
    if ("") { console.log("will this be shown?"); } // ü§î
  </code></pre>

          <pre class="fragment"><code class="javascript">
    if ([]) { console.log("will this be shown?"); } // ü§î
  </code></pre>

          <pre class="fragment"><code class="javascript">
    if ({}) { console.log("will this be shown?"); } // ü§î
  </code></pre>
        </section>

        <!-- ============================================================================= -->
        <section>
          <h3>Truthy und falsy #2</h3>

          <p>Insbesondere mit <code>0</code> und Leerstring aufpassen:</p>

          <pre class="fragment"><code class="javascript">
        function add(a, b) {
          if (!a || !b) {
            throw new Error("Invalid Argument!");
          }

          return a + b;
        }
      </code></pre>
          <pre class="fragment"><code class="javascript">
        add(2, 1);  // 3 üëç
        add(1, null); // "Invalid Argument" üëç
      </code></pre>

          <pre class="fragment"><code class="javascript">
        add(1, 0); // "Invalid Argument" ü§¶
      </code></pre>
        </section>

        <section data-markdown>
          <textarea data-template>
### Truthy und falsy #3

* Mit Default-Werten (Destructuring) und Default-Parametern (Funktionen) aufpassen
* Defaults werden nur verwendet, wenn der entsprechende Wert `undefined` ist
* `truthy` bzw. `falsy` spielen hier keine Rolle!
* ```javascript
  const person = { firstname: null };

  const { firstname = "Susi" } = person; // firstname: null!
  ```
* ```javascript
  function sayHello(name = "Susi") { return "Hello, " + name }

  sayHello(null); // Hello, null
  ```
---
### Operatoren mit truthy/falsy

* Der logische Und-Operator (`&&`) liefert die _rechte_ Seite eines Ausdrucks, wenn der Ausdruck auf der linken Seite `truthy` ist:
* ```typescript
  const a = "eins" && "zwei"; // a === "zwei"
  ```
* Ansonsten wird der Ausdruck auf der linken Seite zur√ºckgeliefert
  * Dieser muss nicht false sein!
  * ```typescript
    const firstName = "";
    const a = firstName.length > 3 && "Name korrekt"; // false
    const b = firstName && "Name ist leer"; // ü§î
    ```
  * ```typescript
    const b = firstName && "Name ist leer"; // ""
    ```
* Bei dem logischen Oder-Operator `||` ist es umgekehrt, _rechte_ Seite wird zur√ºckgeliefert, wenn linke Seite `falsy` ist
* ```typescript
  const a = "".length || "Name ist leer"; // "Name ist leer"
  const b = "Klaus".length || "Name ist leer"; // 5
```
* Der [Nullish coalescing operator](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Nullish_coalescing) liefert
den _rechten_ Ausdruck nur zur√ºck, wenn der linke Ausdruck `null` oder `undefined` ist:
* ```typescript
  const name = null;
  const msg = name ?? "Name ist null"; // Name ist null

  const firstname = "";
  const err = firstname ?? "Name ist leer"; // ""
  ```

    




  </textarea
          >
        </section>
        <!-- ============================================================================= -->
        <section>
          <h2>√úbung: Arbeiten mit Objekten</h2>

          <p class="fragment">
            Die Beschreibung der √úbung findest Du in
            <b><code>js-intro/03_objects/index.js</code></b
            >. Darin kannst Du auch deinen Code schreiben.
          </p>
          <p class="fragment">
            Du kannst
            <b><code>js-intro/03_objects/index.html</code></b> in deinem Browser √∂ffnen. Diese Datei
            f√ºhrt die <b><code>index.js</code></b
            >-Datei dann aus.
          </p>
          <p class="fragment">
            Ausgaben auf der Browser-Konsole, nach dem √Ñndern von <code>index.js</code>, die Seite
            im Browser neu laden
          </p>
          <p class="fragment">Bei Fragen oder Problemen, kannst Du dich jederzeit melden</p>
          <p class="fragment">
            Wenn alle Stricke rei√üen, findest Du eine m√∂gliche L√∂sung in:
            <code>js-intro/03_objects/solution/index.js</code>
          </p>
          <p class="fragment">Wenn Du fertig bist, bitte "Hand heben" in Zoom üôã‚Äç‚ôÄÔ∏è</p>
        </section>

        <!-- =============================================================================
        <section>
          <h3>Weitere Operatoren</h3>

          <p>
            <a
              href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Logical_OR"
              >OR</a
            >
          </p>

          <pre class="fragment"><code class="javascript">
              const winter = true;
              const summer = false;
              const spring = false;
              const isWinterOrSummer = winter || summer; // true
              const isSummerOrSpring = summer || spring; // false 

            </code></pre>

          <pre class="fragment"><code class="javascript">
            // Mit nicht-boolean-Werten
            const name = "Peter";
            const age = 32;
            const oneOrTheOther = name || age; // Peter
          </code></pre>

          <pre class="fragment"><code class="javascript">
            // Mit nicht-boolean-Werten
            const name = "";
            const age = 32;
            const oneOrTheOther = name || age; // ???
          </code></pre>

          <pre class="fragment"><code class="javascript">
            // OR...?
            const name = "";
            const age = 0;
            const what = name || age; // ????
          </code></pre>
        </section>

        <section>
          <h3>Weitere Operatoren</h3>
          <p>
            <a
              href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Logical_AND"
              >AND</a
            >
          </p>
          <p>Liefert den zweiten Wert zur√ºck (oder ersten Wert, wenn erster Wert falsy)</p>

          <pre class="fragment"><code class="javascript">
            const winter = true;
            const summer = false;
            const winterAndSummer = winter && summer; // false; 
          </code></pre>

          <pre class="fragment"><code class="javascript">
            const firstname = "Susi";
            const lastname = "Meier"
            const name = firstname && lastname; // Susi
          </code></pre>

          <pre class="fragment"><code class="javascript">
            const firstname = "";
            const lastname = "Meier"
            const firstnameAndLastNameSpecified = firstname && lastname; // "" üòù
          </code></pre>

          <pre class="fragment"><code class="javascript">
            const firstname = "Abc";
            const lastname = "Meier"
            const firstnameAndLastNameSpecified = !!(firstname && lastname); // true üòù
          </code></pre>
        </section> -->
        <section data-markdown>
          <textarea data-template>
### Klassen

* Klassen k√∂nnen in JavaScript mit `class` erzeugt werden
* Sie sind von der Syntax und von den M√∂glichkeiten etwas anders als in Java.
* In JavaScript spielen sie eher eine untergeordnete Rolle
  * Insbesondere tiefe Vererbungshierarchien sind eher ungew√∂hnlich
  * Meist werden einfache Objekte, Funktionen und/oder Closures verwendet
  * Zum Arbeiten mit stateful Daten (z.B. Caches) aber durchaus n√ºtzlich
* ```typescript
  class Person {
    firstname;

    constructor(f) {
      this.firstname = f;
    }

    sayHello() {
      return `Hello, ${this.firstname}`
    }
  }
  ```
---
### Klassen

* Alle Eigenschaften in einer Klasse sind per Default **public**
* Auf die Eigenschaften muss auch innerhalb der Klasse **immer** mit `this` zugegriffen werden
* ```typescript
  class Person {
    firstname = "Susi";

    sayHello() {
      return `Hello, ${firstname}` // ReferenceError: firstname is not defined
    }
  }
  ```

* Es kann max. einen Konstruktor geben, der `constructor` heisst



---
### Vererbung
* Mit `extends` kann eine Klasse von einer anderen erben
* Wenn die Oberklasse einen `constructor` hat, muss die Unterklasse auch einen
  Konstruktur haben und als erstes `super()` aufrufen
* Mit `super` haben wir in der Unterklasse Zugriff auf die Eigenschaften der Oberklasse (wie in Java)  
* ```typescript
  class Person {
    firstname;
    constructor(firstname) { this.firstname = firstname; }
    sayHello() { return `Hello, ${this.firstname}` }
  }
  ```
* ```typescript
  class Employee extends Person {
    company;
    constructor(firstname, company) {
      super(firstname);
      this.company = company;
    }
    sayHello() {
      return `${super.sayHello()} working at ${this.company}`
    }

    increaseSallary() { }
  }
  ```
* ```typescript
  const p = new Person("Klaus");
  p.sayHello(); // "Hello, Klaus"  

  const e = new Employee("Susi", "Hier GmbH");
  e.sayHello(); // "Hello, Susi working at Hier GmbH"
  e.increaseSallary(); // OK

  p.increaseSallary(); TypeError: p.increaseSallary is not a function 
  ```
---
### Statische Methoden und Felder
* Statische Methoden und Felder werden mit `static` angegeben
* Zugriff meistens mit `Klassenname.statischeEigenschaft`:
* ```typescript
  class Person {
    static verifyAge(a) { return a > 18 }

    setAge(newAge) {
      // Zugriff aus Klasse:
      Person.verifyAge(a);
    }
  }

  // Zugriff von au√üerhalb:
  Person.verifyAge(23);

  ```
* Innerhalb einer statischen Methode kann auf andere statische Eigenschaften mit `this` zugegriffen werden:
* ```typescript
  class Person {
    static minAge = 18;
    static verifyAge(a) { return a > this.minAge }
    // ...
  }
  ```
* Statische Eigenschaften k√∂nnen in Unterklassen √ºberschrieben werden:
* ```typescript
  class Person {
    static minAge = 18;
    static verifyAge(a) { return a > this.minAge }
    // ...
  }

  class Senior extends Person {
    static minAge = 32;
  }

  Person.verifyAge(19) // TRUE
  Senior.verifyAge(19) // FALSE
  Senior.verifyAge(33) // TRUE

  ```

  
---
### Private Eigenschaften
* Statische Methoden, Methoden und Felder k√∂nnen mit einem f√ºhrenden `#` versehen werden
* Diese Eigenschaften sind dann "private" und k√∂nnen nur in der Klasse selbst verwendet werden
  * Auch nicht in Unterklassen
  * Verhalten √§hnlich wie in Java

* ```typescript
  class Person {
    // Privates Feld
    #firstname;

    // Private statische Methode
    static #verifyName(n) {
      if (!n) {
        throw new Error("Illegal name")
      }
    }

    get firstname() {
      return this.#firstname || "Kein Firstname";
    }

    set firstname(f) {
      Person.#verifyName(f);
      this.#firstname = f;
    }
  }

  const p = new Person();
  p.firstname; // "Kein Firstname";
  p.firstname = ""; // Illegal name
  p.firstname = "Klaus"
  p.firstname; // Klaus

  ```
---
### Klassen in TypeScript
* Die Notation ist in TypeScript (fast) identisch
* Es m√ºssen Typ-Annotation f√ºr Felder sowie Constructor- und Methoden-Parameter gemacht werden
* ```typescript
  class Person {
    firstname: string // firstname ist public
    private age: number;

    constructor(n: string, a: number) { this.firstname = n; this.age = age }
  }

  const p = new Person("Klaus", 32);
  p.firstname; // Klaus
  p.age; // TS ERR: Property 'age' is private

  ```
* Methoden und Felder k√∂nnen `public` (default) oder `protected` bzw. `private` sein
* Kurzschreibweise f√ºr Felder:
* ```typescript
  class Person {
    constructor(public firstname: string, private age: number) {}

    sayHello() { return `Hello, ${this.firstname}, you are ${this.age} years old` }
  }

  const p = new Person("Klaus", 32);
  p.sayHello(); // Hello, Klaus, you are 32 years old
  ```
---
### Klassen in TypeScript  
* Klassen k√∂nnen TypeScript Interfaces implementieren
* ```typescript
  interface Greetable { 
    sayHello(s: string): string
  }
  class Greeter implements Greetable { sayHello(s) { return "Hello " + s} }
  class MoinGreeter implements Greetable { sayHello(s) { return "Moin " + s} }

  function greet(g: Greetable) {
    console.log(g.sayHello("Susi"));
  }

  greet(new Greeter()) // Hello Susi
  greet(new MoinGreeter()) // Moin Susi
  ```
* Achtung! Interfaces sind eine TypeScript Sprachererweitung. 
  * Sie nach dem Compilieren weg, und k√∂nnen z.B. nicht mit `instanceof` √ºberpr√ºft werden
---
### Closures
<!-- .slide: class="left" -->
* Eine "normale" Funktion...
* ```typescript
  function count() {
    let v = 1;

    v = v + 1;

    return v;
  }
  ```
* ```typescript
  count(); // 2
  ```
  * Nach der Ausf√ºhrung der Funktion wird diese abger√§umt und mit ihr alle Daten
  * Bei erneuter Ausf√ºhrung der Funktion wird diese neu initialisiert und beginnt von vorne:
* ```typescript
  count(); // 2
  count(); // 2
  count(); // 2
  ```
---
### Closures

* Eine Closure ist eine Funktion, die nicht nur "sich selbst", sondern auch ihre Umgebung (√§u√üere Funktion(en)) kennt
* Dadurch kann diese Funktion eine "Instanz" haben
* Im Gegensatz zu einer "normalen" Funktion, beh√§lt die Closure ihre "inneren" Daten (Variablen, Funktionen) 
* Diese Daten werden _Closures_ genannt und nicht von der Laufzeitumgebung abger√§umt
* ```typescript
  function counter() {
    let v = 1;

    function count() {
      v = v + 1;
      return v;
    }

    return count;
  }
  ```
* ```typescript
  const c = counter(); // counter liefert 'count'-Funktion zur√ºck!
  c(); // 2
  c(); // 3
  c(); // 4

  const d = counter(); // zweite "Instanz" von count!
  d(); // 2
  d(); // 3

  ```
* Die Daten/Closures von `counter` w√ºrden hier erst abger√§umt, wenn `c` bzw. `d` nicht mehr verwendet werden 
---
### Closures
* Eine Closure hat Zugriff auf alle √§u√üeren "Scopes", bis hin zum globalen Scope
* ```typescript
  let c = 1;
  function counter() {
    let d = c + 1; // Zugriff auf globalen Scope

    function count() {
      let e = c + d; // Zugriff auf h√∂heren und globalen Scope
      return e;
    }
  }
  ```
* Von au√üen kann man nicht in die Closure eingreifen
* Dadurch kann man z.B. Sichtbarkeiten implementieren
* ```typescript
  function calculator(initialValue) {
    let value = initialValue ?? 0; // "privat"

    function assertValidNumber(v) { // "privat"
      if (typeof v !== "number") { throw new Error("not a number!") }
    }

    function add(v) {
      assertValidNumber(v);
      value = value + v;
      return value;
    }

    function substract(v) {
      assertValidNumber(v);
      value = value - v;
      return value;
    }

    return { add, substract };
  }
  ```
* ```typescript
  const c = calculator(2);
  c.add(1); // 3
  c.substract(4); // -1
  ```
---
### Lambda
<!-- .slide: class="left" -->
* Begriffe Lambda und Closure werden manchmal synonym verwendet
* Als _Lambda_ wird aber eine anonyme, innere Funktionen bezeichnet
* ```typescript
  function addListener(fn) { ... }

  function app() {
    registerListener( () => console.log("Event!") ); // Lambda
  }
  ```
* In _Java_ ist eine Lambda keine "echte" Closure
* Darum m√ºssen in _Java_ verwendete Variablen "effective final" sein
  * ```java
    // Java !!
    class A {
      void multiply(List<Integer> values) {
          int v = 2;
          values.stream().map(i -> i * v); // OK, lese-Zugriff auf v
      }

      void sum(List<Integer> values) {
          int sum = 0;
          values.stream().forEach(i -> sum += i ); // ERR: Variable used in lambda expression 
                                                  // should be final or effectively final
      }
    }
    ```
  



  


---
### Typ von Funktionen
<!-- .element: class="todo" -->eventuell raus
* Eine `function` ist eine "Unterklasse" eines Objekts in in JavaScript und kein eigener Datentyp
* ```typescript
  function greet(msg) {
    return "Hello, " + msg;
  }

  greet instanceof Object; // true
  ```
* `typeof` liefert f√ºr eine Funktion (trotzdem) den eindeutigen String `function` zur√ºck:
* ```typescript
  function greet(msg) {
    return "Hello, " + msg;
  }

  typeof greet; // "function"
  ```
* auch eine Klasse ist √ºbrigens eine Funktion:
* ```typescript
  class Greeter { 
    greet(msg) { 
      console.log("Hello, " + msg);
    }
  }
  
  typeof Greeter; // "function" ü§¶
  ```
---
### √úbung: Klassen und Closures

* *Implementiere einen einfachen Cache* als **Closure** und als **Klasse**
* In `06_closures_and_classes` findest Du zwei JavaScript-Dateien:
  * In der Datei `make_cache_class.js` baust Du den Cache als JavaScript Klasse:
  * In der Datei `make_cache_closure.js` baust Du den Cache als Closure
* Aufgabe und Beschreibung ist in beiden Dateien unterschiedlich, nur deine Implementierung unterscheidet sich :-)
* L√∂sung findest Du in `solution`
* Wenn Du fertig bist, bitte Hand in Zoom heben üôã  
  </textarea
          >
        </section>
        <!-- ============================================================================= -->
        <section>
          <h3>Module</h3>
          <p>Mit Modulen sind Dateiinhalte nicht mehr global sichtbar</p>
          <p>Module bestimmen explizit, was au√üerhalb verwendet werden darf</p>
          <p>Module geben explizit an, was sie aus anderen Modulen verwenden wollen</p>
        </section>

        <!-- ============================================================================= -->
        <section>
          <h3>Module</h3>
          <h4>Default Exporte</h4>
          <p>
            <em
              >Objekte, Funktionen, Klassen etc m√ºssen explizit <b>exportiert</b> und
              <b>importiert</b> werden</em
            >
          </p>
          <p class="fragment">Eine <code>export</code>-Anweisung macht aus einer Datei ein Modul</p>

          <pre class="fragment"><code class="javascript">
            // src/domain/Person.js
            export default function createPerson { ... }

            oder

            function createPerson { ... }
            export default createPerson
          </code></pre>

          <pre class="fragment"><code class="javascript">
              // src/domain/Person.js
              export default function createPerson() { ... }

              oder

              function createPerson() { ... }
              export default createPerson;
            </code></pre>

          <pre class="fragment"><code class="javascript">
                Nur EIN Default Export erlaubt;
                export default function createPerson() { ... }
                export default function makePerson { ... } // KONFLIKT
              </code></pre>
        </section>

        <!-- ============================================================================= -->
        <section>
          <h3>Module</h3>
          <h4>Importieren</h4>
          <p class="fragment">Beim importieren geben wir Pfade(!) an</p>

          <pre class="fragment"><code class="javascript">
              // src/domain/Person.js
              export default function createPerson() { ... }

            </code></pre>

          <pre class="fragment"><code class="javascript">
                // src/App.js
                import createPerson from "./domain/Person.js";

                const person = createPerson("Lemmy", "Kilmister");
              </code></pre>
        </section>

        <!-- ============================================================================= -->
        <section>
          <h3>Module</h3>
          <h4>Benannte Exporte</h4>
          <p class="fragment">
            Ein Modul kann neben einem Default auch beliebig viele
            <b>benannte Exporte</b> haben
          </p>

          <pre class="fragment"><code class="javascript">
                // src/domain/Person.js
                export default function createPerson { ...}

                export function updatePerson() { ... }
                export function removePerson() { ... }
              </code></pre>

          <pre class="fragment"><code class="javascript">
                  // src/domain/Person.js
                  function createPerson { ...}
                  function updatePerson() { ... }
                  function removePerson() { ... }

                  export default createPerson;

                  export { updatePerson, removePerson }
                </code></pre>
        </section>

        <!-- ============================================================================= -->
        <section>
          <h3>Module</h3>
          <h4>Benannte Importe</h4>
          <pre class="fragment"><code class="javascript">
                    // src/App.js
                    import { removePerson } from "./Person"
              </code></pre>
          <pre class="fragment"><code class="javascript">
                // Default und benannten Export importieren
                import createPerson, { removePerson } from "./Person.js"
              </code></pre>
        </section>
        <!-- ============================================================================= -->
        <!-- <section>
          <h3>√úbung: Module</h3>

          <p>Vorbereitung</p>
          <ol>
            <li class="fragment">
              √ñffne das Verzeichnis <code>js-intro/04_modules</code> im Terminal
            </li>
            <li class="fragment">F√ºhre <code>npx http-server</code> in dem Verzeichnis aus</li>
            <li class="fragment">
              √ñffne die Seite <a href="http://localhost:8080">http://localhost:8080</a> im Browser
            </li>
            <li class="fragment">Wenn Du die Seite ge√∂ffnet hast, bitte "Hand heben" in Zoom üôã‚Äç‚ôÄÔ∏è</li>
          </ol>
        </section>

        <section>
          <h2>√úbung: Module</h2>

          <p class="fragment">
            Die Beschreibung der √úbung findest Du in
            <b><code>js-intro/04_modules/index.js</code></b
            >. Darin kannst Du auch deinen Code schreiben.
          </p>
          <p class="fragment">
            Du kannst
            <b><code>js-intro/04_modules/index.html</code></b> in deinem Browser √∂ffnen. Diese Datei
            f√ºhrt die <b><code>index.js</code></b
            >-Datei dann aus.
          </p>
          <p class="fragment">
            Ausgaben auf der Browser-Konsole, nach dem √Ñndern von <code>index.js</code>, die Seite
            im Browser neu laden
          </p>
          <p class="fragment">Bei Fragen oder Problemen, kannst Du dich jederzeit melden</p>
          <p class="fragment">
            Wenn alle Stricke rei√üen, findest Du eine m√∂gliche L√∂sung in:
            <code>js-intro/04_modules/solution/</code>
          </p>
          <p class="fragment">Wenn Du fertig bist, bitte "Hand heben" in Zoom üôã‚Äç‚ôÄÔ∏è</p>
        </section>  -->
        <!-- ============================================================================= -->
        <section data-markdown>
          <textarea data-template>
### Modulsysteme: Common JS vs ECMAScript Module

* Common JS ist das Modulsystem von Node.JS
* Node.JS unterst√ºtzt mittlerweile aber auch das JavaScript Modulsystem
* Probleme kann es geben, wenn beide Modulsystem
---
### Unterschiede
* CommonJS Module werden synchron geladen, ES Module hingegen asynchron
  * Das macht einen Mischbetrieb f√ºr die Laufzeitumgebung komplex
* CommonJS Module funktionieren nicht im Browser 
* CommonJS flexibler, `require` kann √ºberall verwendet werden, `import` nur am Beginn einer Datei
---
### Dateiendung vs. package.json
* 
          </textarea>
        </section>

        <section>
          <h2>Geschafft! üòä</h2>
          <h3>Vielen Dank f√ºr Eure Teilnahme!</h3>
          <h3>Viel Spa√ü und Erfolg weiterhin!</h3>
          <p>Wenn ihr noch Fragen habt, k√∂nnt ihr mich erreichen:</p>
          <p>Mail: <a href="mailto:nils@nilshartmann.net">nils@nilshartmann.net</a></p>
          <p>
            Web: <a href="https://nilshartmann.net" target="_blank">https://nilshartmann.net</a>
          </p>
          <p>
            Twitter: <a href="https://twitter.com/nilshartmann" target="_blank">@nilshartmann</a>
          </p>
        </section>
      </div>
    </div>

    <script src="slides/revealjs/reveal.js/dist/reveal.js"></script>
    <script src="slides/revealjs/reveal.js/plugin/notes/notes.js"></script>
    <script src="slides/revealjs/reveal.js/plugin/markdown/markdown.js"></script>
    <script src="slides/revealjs/reveal.js/plugin/highlight/highlight.js"></script>
    <script src="slides/revealjs/config.js"></script>
  </body>
</html>
